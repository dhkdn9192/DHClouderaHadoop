# Part 2 분산 데이터

- 여러 장비 간 분산 데이터베이스가 필요한 이유
    - **확장성** : 단일 장비로 처리하기 어려운 읽기, 쓰기 부하와 데이터 볼륨 문제를 여러 장비로 분배
    - **내결함성 및 고가용성** : 한 장비가 죽어도 다른 장비가 이어 받는다.
    - **지연 시간** : 글로벌 서비스의 서버가 지리적으로 가까운 데이터센터에도 분산되어 있으면 지연시간을 줄일 수 있다.
- 고부하 확장을 위한 방법
    - **공유 메모리 아키텍처(shared-memory architecture)**
        - 모든 구성 요소를 단일 장비처럼 다룰 수 있다.
        - 장비 업그레이드 비용이 선형적이지 않고 기하급수적으로 증가한다.
        - 내결함성이 제한적이다.
    - **공유 디스크 아키텍처**
        - 독립적인 CPU와 RAM을 탑재한 여러 장비가 데이터를 저장하는 디스크 배열만 공유한다. (네트워크 연결)
        - 여전히 확장성에 제한이 있다.
    - **비공유 아키텍처(shared-nothing)**
        - 각 노드가 CPU, RAM, 디스크를 독립적으로 사용한다.
        - 노드 간 코디네이션은 소프트웨어 수준에서 이뤄진다.
        - 특별한 전용 하드웨어가 아닌 일반적인 범용 제품을 사용할 수 있다.
        - 데이터를 여러 노드에 분산하려면 **분산 시스템에서 발생하는 제약 조건과 트레이드오프**를 알고 있어야 한다.
- 여러 노드에 데이터를 분산하는 방법
    - **복제**
        - 같은 데이터의 복사본을 여러 노드에 유지한다.
        - 복제는 중복성을 제공하며 노드 장애에 대한 **가용성**과 데이터 처리에 대한 **성능 향상**을 제공한다.
    - **파티셔닝**
        - 큰 데이터베이스를 파티션이라는 서브셋으로 나누고 각기 다른 노드에 할당한다. → **샤딩**이라고도 한다.

# 05장 - 복제

- **복제**란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것
- 복제가 필요한 이유
    - 지리적으로 가까운 데이터로 **지연 시간을 줄인다**.
    - **장애**가 발생해도 시스템이 동작하도록 **가용성**을 높인다.
    - **읽기 처리량**을 늘린다.
- 복제의 어려운 점은 복제된 데이터의 **변경** 처리에 있다.
- 노드 간 변경을 복제하기 위한 알고리즘
    - **단일 리더(single-leader)** 복제
    - **다중 리더(multi-leader)** 복제
    - **리더 없는(leaderless)** 복제
- 복제에 고려해야 할 트레이드오프
    - **동기식 복제**와 **비동기식 복제** 중 어떤 것을 선택할 것인가
    - **잘못된 복제본**을 어떻게 처리할 것인다.

## 리더와 팔로워

- **복제 서버(replica)** : 데이터베이스의 복사본을 저장하는 각 노드
- 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할 수 있나?
    - DB의 모든 쓰기는 모든 복제 서버에서 처리돼야 한다.
- **리더 기반 복제(leader-based replication)**
    - 복제 서버 중 하나를 **리더(leader)** 로 (master, primary라고도 함), 나머지는 **팔로워(follower)** 로 지정한다. (read replica, slave, secondary, hot standby라고도 함)
    - 쓰기 요청
        - 클라이언트의 쓰기 요청은 리더에게 보내야 한다.
        - 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.
        - 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 **복제 로그(replication log)** 또는 **변경 스트림(change stream)** 형태로 팔로워에게 전송한다.
        - 팔로워는 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 자신의 로컬 복사본을 갱신한다.
    - 읽기 요청
        - 클라이언트의 읽기 요청은 리더와 임의 팔로워 모두에 질의 가능 (즉 팔로워는 클라이언트 관점에선 읽기 전용임 셈)
    - 이 복제 모드는 여러 관계형 DB 뿐만 아니라 일부 비관계형 DB에서도 사용한다. (MongoDB, 리싱크DB, 에스프레소)
    - DB에만 국한되지 않고 Kafka, RabbitMQ 등 분산 메시지 브로커에도 사용된다.

### 동기식 대 비동기식 복제

- 복제가 **동기식**으로 발생하는가? 아님 **비동기식**으로 발생하는가?

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/de5db514-3394-4ec8-9c7d-cb994d21b5bf)

- **동기식**
    - 위 예제의 팔로워1에 해당
    - 리더는 팔로워의 쓰기 수식 확인을 기다려준다.
    - 장점
        - 팔로워가 리더와 일관성 있게 최신 복사본을 가지는 것을 보장한다.
        - 즉, 리더가 작동하지 않아도 팔로워의 데이터를 계속 사용할 수 있다.
    - 단점
        - 팔로워가 응답하지 않으면 쓰기 처리가 계속 지연된다.
    - 임의의 한 노드 장애가 전체 시스템을 멈추게 하므로 모든 팔로워가 동기식인 것은 비현실적이다.
    - 따라서 현실적으로 팔로워 **하나만 동기식**으로, **나머지는 비동기식**으로 하고 동기식 팔로워가 다운되면 비동기식 팔로워 중 하나가 동기식이 된다. → **반동기식(semi-synchronous)**
- **비동기식**
    - 위 예제의 팔로워2에 해당
    - 리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않는다.
    - 장점
        - 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있다.
    - 단점
        - 리더가 잘못 되고 복구할 수 없으면 팔로워에 복제되지 않은 모든 쓰기가 유실된다.
        - 이 때문에 좋은 성능과 가용성을 제공하면서 데이터 유실이 없는 복제 방법이 계속 연구 중이다. (MS Azure의 체인 복제 등)
    - 일반적으로 팔로워가 많거나 지리적으로 분산되었다면 **비동기식 복제를 널리 사용**한다.

### 새로운 팔로워 설정

- scale-out, 장애 노드 대체 등으로 추가된 **새로운 팔로워**가 리더의 데이터 **복제본을 정확히 가지고 있는지 어떻게 보장**할까?
- 한 노드의 데이터 파일 복사만으로는 충분하지 않다.
    - DB의 데이터 기록이 지속적이므로 데이터는 항상 유동적이다.
    - 표준 파일 복사본은 시점에 따라 DB의 다른 부분을 보게 되므로 복사 결과가 유효하지 않을 수 있다.
- 그렇다고 DB의 쓰기를 중단하고 일관성을 확보하는 것은 가용성 목표에 부합하지 않는다.
- 따라서 일반적으로 리더의 DB **스냅숏**을 이용하여 중단시간 없이 수행한다.
    - 리더의 DB 스냅숏을 일정 시점에 가져온다. (대부분의 DB는 백업이 필요하므로 이 기능을 갖추고 있다.)
    - 스냅숏을 새로운 팔로워 노드에 복사한다.
    - 팔로워는 리더에 연결해 **스냅숏 이후 발생한 모든 데이터 변경을 요청**한다.
        - 리더의 복제 로그의 정확한 위치는 PostgreSQL에선 **log sequence number**, MySQL에선 **binlog coordinate** 라 부른다.
    - 팔로워가 스냅숏 이후 데이터 변경의 **미처리분(backlog)** 을 모두 처리하고 나면 리더에 발생하는 데이터 변화를 이어 처리할 수 있게 된다.

### 노드 중단 처리

- 개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화해야 한다.
- 리더 기반 복제에서 고가용성을 어떻게 달성할 수 있을까?
- **팔로워 장애 : 따라잡기 복구**
    - 팔로워가 죽어서 재시작하거나 일시적 네트워크 중단의 경우, 팔로워 복구는 매우 쉽다.
    - 팔로워는 로컬 디스크의 변경 로그에서 결함 전 처리한 마지막 트랜잭션을 파악한다.
    - 리더에 연결하여 연결이 끊어진 동안 발생한 모든 데이터 변경을 요청한다.
    - 이 따라잡기가 다 적용되면 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있게 된다.
- **리더 장애 : 장애 복구**
    - **장애 복구(failover)** 과정
        - 팔로워 중 하나를 새로운 리더로 승격하고,
        - 클라이언트는 새로운 리더로 쓰기 요청을 보내도록 재설정이 필요하며,
        - 다른 팔로워는 새로운 리더로부터 데이터 변경을 수신을 시작해야 한다.
        - 즉, 리더의 장애를 처리하는 일은 팔로워보다 까다롭다.
    - **자동 장애 복구**의 단계
        - **리더가 장애인지 판단한다** : **타임아웃**을 사용
        - **새로운 리더를 선택한다** : **선출 과정**으로 뽑거나 **제어 노드(controller node)** 에 의해 임명
        - **새로운 리더 사용을 위해 시스템을 재설정한다** : 클라이언트가 새로운 리더에게 쓰기 요청을 보내야 하며, 이전 리더가 돌아오면 자신이 팔로워가 되고 새로운 리더를 인식할 수 있어야 한다.
    - 장애 복구 과정은 잘못될 수 있는 것 투성이다.
        - 비동기식 복제라면 **새로운 리더가 수신하지 못 한 이전 리더의 쓰기**가 있을 수 있다. 이전 리더가 다시 추가된다면 이 쓰기를 어떻게 처리할까? → **폐기**가 일반적인 해결책이지만 **내구성에 대한 기대**를 저버리게 된다.
        - 쓰기 폐기는 DB 외부의 다른 저장소 시스템이 DB 내용에 맞춰 조정돼야하는 경우 특히 위험하다. (github에서 발생한 out-of-date MySQL 팔로워가 리더로 승격된 사례)
        - **스플릿 브레인(split brain)** : 두 노드가 모두 자신이 리더라고 믿는 상황. 쓰기 충돌이 해소되지 않으면 데이터가 유실되거나 오염된다.
        - 리더가 죽었다고 판단할 **적절한 타임아웃** 시간 : 너무 짧으면 불필요한 failover가 있을 수 있고, 너무 길면 리더 복구까지 오랜 시간이 걸린다.

### 복제 로그 구현

- 리더 기반 복제가 내부적으로 동작하는 다양한 방법들
    - 구문 기반 복제, WAL shipping, 로우 기반 로그 복제, 트리거 기반 복제
- **구문 기반 복제**
    - 리더는 모든 쓰기 요청(즉 **구문, statement**) 를 기록 및 실행한 다음 구문 로그를 팔로워에 전송한다.
    - 관계형 DB는 모든 INSERT, UPDATE, DELETE 구문을 팔로워에게 전달, 각 팔로워는 전달받은 SQL 구문을 파싱하고 실행한다.
    - 이 접근법은 복제가 깨질 수 있는 다양한 사례가 존재한다.
        - NOW(), RAND() 등 **비결정적 함수**를 호출하는 경우 서버마다 다른 값을 생성할 수 있다.
        - 자동증가 칼럼, DB에 있는 값에 의존하는 구문 등은 각 복제 서버에서 **정확히 같은 순서로 실행**돼야 한다. 이는 동시에 여러 트랜잭션이 수행되는 것을 제한한다.
        - 트리거, 스토어드 프로시저, UDF 등 **부수 효과**를 가진 구문은 부수 효과가 완벽하게 결정적이지 않으면 각 서버가 다른 부수 효과를 갖게 된다.
    - 비결정적 함수 호출을 고정값을 반환하게끔 대체하는 등 해결책이 있으나, 일반적으로 다른 복제 방법을 선호한다.
- **쓰기 전 로그 배송(WAL shipping)**
    - 3장에서 살펴본 로그 구조화 저장소 엔진(SS테이블, LSM트리) 및 B 트리에서 **로그는 DB의 모든 쓰기를 포함하는 append-only 바이트열**이라는 것을 알 수 있다.
    - 즉, **팔로워가 리더의 WAL을 전송받아 처리하면 리더와 동일한 데이터 구조의 복제본을 만들 수 있다**.
    - WAL을 사용하는 방식의 단점 : **복제가 저장소 엔진과 밀접하게 엮이게 된다**. (바이트 수준)
    - 즉, DB가 저장소 형식을 다른 버전으로 변경하면 보통 리더와 팔로워의 DB 소프트웨어 버전을 다르게 실행할 수 없다.
    - 팔로워가 리더보다 새로운 소프트웨어 버전을 사용하도록 복제 프로토콜이 허영한다면 팔로워 먼저 업그레이드 함으로써 중단시간 없이 소프트웨어 업그레이드가 가능하다.
    - 반면, WAL shipping과 같이 복제 프로토콜이 버전의 불일치를 허용하지 않는다면 **업그레이드를 위해 중단시간이 필요**하다.
- **논리적(로우 기반) 로그 복제**
    - **논리적 로그(logical log)** : 복제 로그를 저장소 엔진(물리적) 내부와 **분리**하기 위해 다른 로그 형식을 사용한다.
    - 관계형 DB용 논리적 로그는 보통 로우 단위로 테이블 쓰기를 기술한 레코드 열이다.
        - **삽입된 로우의 로그** : 모든 칼럼의 새로운 값 포함
        - **삭제된 로우의 로그** : 로우 식별 정보 포함 (기본키. 없으면 모든 칼럼의 예전 값 로깅해야 함)
        - **갱신된 로우의 로그** : 로우 식별 정보 포함 + 모든 칼럼의 새로운 값
    - MySQL의 binlog가 이 접근 방식을 사용한다.
    - 논리적 로그를 저장소 엔진 내부와 분리하여 얻는 장점
        - **하위 호환성**을 더 쉽게 유지할 수 있다.
        - 리더와 팔로워에서 다른 버전의 DB 소프트웨어나 다른 저장소 엔진을 실행할 수 있다.
        - 논리적 로그 형식은 외부 애플리케이션에서 파싱하기 더 쉽다.
- **트리거 기반 복제**
    - 앞서 살펴본 복제 접근 방식은 애플리케이션 코드의 사용 없이 DB 시스템에 의해 구현된다.
    - 그러나 앞의 방식들보다 **유연성**이 필요한 일부 케이스가 존재한다.
        - 데이터의 서브셋만 복제하는 경우
        - DB를 다른 종류의 DB로 복제해야 하는 경우
        - 충돌 해소 로직이 필요하여 복제를 애플리케이션 층으로 옮겨야 하는 경우 등
    - 오라클 GoldenGate 같은 도구는 **DB 로그를 읽어 애플리케이션이 데이터를 변경**할 수 있게 해준다.
    - 다른 방법으로 많은 관계형 DB에서 사용하는 **트리거**나 **스토어드 프로시저**를 사용한다.
    - 트리거는 사용저 정의 애플리케이션 코드를 등록하여 DB의 데이터가 변경되면 자동으로 코드를 실행하도록 해준다.
    - 일반적으로 트리거 기반 복제는 다른 복제 방식보다 오버헤드가 크고 버그, 제한 사항이 더 많이 발생한다.
    - 그럼에도 유연성이 필요한 경우에 유용하다.

## 복제 지연 문제

- 복제는 **노드 내결함성** 뿐만 아니라 **확장성**, **지연 시간**에도 장점이 있다.
- **읽기 확장(read-scaling)**
    - 대부분이 읽기 요청이고 쓰기가 작은 비율이라면 많은 팔로워에 읽기 요청을 분산할 수 있다.
    - 즉, 간단히 팔로워를 추가함으로써 읽기 처리 용량을 늘릴 수 있다.
    - 이 방식은 **비동기식 복제에서만 동작**하며 동기식은 단일 노드 장애나 네트워크 장애가 전체 시스템의 쓰기 불능으로 이어지므로 어렵다.
- **최종적 일관성**
    - 애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 **지난 정보**를 볼 수도 있다.
    - 즉, **DB에 명백한 불일치**가 생기며 리더와 팔로워에 동일한 질의를 수행해도 서로 다른 결과를 얻을 수 있게 된다.
    - 그러나 이런 불일치는 **일시적 상태**에 불과하며 DB에 쓰기를 멈추고 잠시 기다리면 결국 팔로워가 따라잡게 되고 리더와 일치하게 된다. 이를 최종적 일관성이라 한다.
    - 얼마나 뒤처져도 되는지 등 “최종적” 용어는 모호한 부분이 있다.

### 자신이 쓴 내용 읽기

- 사용자는 쓰기 요청을 리더에게 전송해야하지만 읽기는 팔로워에서 읽을 수 있다.
- 비동기식 복제의 문제 : 사용자가 **쓰기를 수행한 직후엔 아직 팔로워에는 반영되지 않았을 수 있다**. 이는 사용자 입장에선 제출한 데이터가 유실된 것처럼 보이므로 불만족스러운 동작이다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/101b5d33-a0c9-44eb-8848-e662a8a522d2)

- 이런 상황에선 **쓰기 후 읽기 일관성(자신의 쓰기 읽기 일관성)** 이 필요하다.
    - 사용자가 페이지를 재로딩했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해선 보장하지 않는다.
- 이를 구현하기 위한 방법들
    - **사용자가 수정한 내용**을 읽을 땐 **리더**에서, 그 밖에는 팔로워에서 읽는다 (e.g. SNS 사용자 프로필은 소유자만 편집할 수 있으므로 수정 후 리더에서 읽더라도 리더의 부하가 적다.)
    - 애플리케이션 내 대부분의 내용을 사용자가 편집할 수 있다면 대부분 리더에서 읽기 때문에 비효율적이다. 이 경우 **리더에서 읽을지 여부를 정할 기준이 필요**하다. (e.g. 마지막 갱신 후 1분 동안은 리더에서 모든 읽기 수행)
    - 클라이언트가 가장 최근의 쓰기 타임스탬프를 기억하여, 읽기 수행 시엔 **복제 서버가 해당 타임스탬프까지 갱신을 반영하도록** 한다. (e.g. 복제 서버가 따라잡을 때까지 질의 대기)
    - 복제 서버가 여러 데이터센터에 분산됐다면 복잡도가 증가하므로 **리더가 제공해야할 모든 요청은 리더가 포함된 데이터센터로 라우팅**되어야 한다.
- 동일한 사용자가 여러 디바이스를 사용하는 경우엔 **디바이스 간(cross-device) 쓰기 후 읽기 일관성**이 제공돼야 한다.
    - 사용자의 마지막 갱신 타임스탬프를 기억하는 방식은 다른 디바이스에서 발생한 갱신을 알 수 없으므로 이런 **메타데이터를 중앙집중식으로 관리**해야 한다.
    - 리더에서 읽어야 할 필요가 있는 접근법이라면 먼저 **사용자 디바이스의 요청을 동일한 데이터센터로 라우팅**해야 한다.

### 단조 읽기

- 비동기식 팔로워에서 읽을 때 발생하는 두 번째 이상 현상은 **사용자가 시간이 거꾸로 흐르는 현상을 목격**할 수 있다는 것

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/f672ffc3-dd11-4bd8-9603-aab755fa7fd5)

- 팔로워 1은 지연이 거의 없고, 팔로워 2는 큰 지연이 있는 예시
- 위 예시에서 사용자 2345는 동일한 질의를 두 팔로워에 수행하지만 첫 번째 질의는 최신 데이터를 반환하는 반면, 두 번째 질의는 그 보다 과거의 데이터를 보여주어 사용자를 혼란스럽게 한다.
- **단조 읽기(monotonic read)**
    - 단조 읽기는 이런 이상 현상이 발생하지 않음을 보장한다.
    - 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 강한 보장
    - 사용자가 새로운 데이터를 읽은 후에는 그 보다 예전 데이터를 읽지 않게 한다.
    - 단조 읽기를 달성하는 한 방법은 **사용자의 읽기가 항상 동일한 복제 서버에서 수행되도록 하는 것**이다. (e.g. 사용자 ID의 해시를 기반으로 복제 서버 선택)
    - 단, 이 경우 복제 서버가 고장나면 사용자의 질의를 다른 복제 서버로 재라우팅할 필요가 있다.

### 일관된 순서로 읽기

- 복제 지연으로 인한 세 번째 이상 현상은 **인과성의 위반** 우려이다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/96089e5a-ffc5-48a9-97c4-1cd25f8c6518)

- 논리적으로 인과성을 가지는 여러 질의가 실제로는 순서대로 수행되었지만 복제 지연으로 인해 제 3의 관찰자가 보기에는 인과 순서가 지켜지지 않는 것처럼 보이는 현상이다. (질문하기도 전에 대답이 먼저 나온 것처럼 보임)
- 이를 방지하려면 **일관된 순서로 읽기(Consistent Prefix Read)** 같은 보장이 필요하다.
    - 일련의 쓰기가 특정 순서로 발생했다면 이를 읽는 사용자는 같은 순서로 쓰여진 내용을 읽게 되는 것을 보장한다.
- 위와 같은 이상 현상은 **파티셔닝(샤딩)된 데이터베이스에서 발생하는 특징적인 문제**이다.
    - DB가 항상 같은 순서로 쓰기를 적용하면 항상 일관된 순서를 보기 때문에 이런 이상 현상이 안 일어난다.
    - 그러나 **분산 DB에서 서로 다른 파티션은 독립적으로 동작**하므로 **쓰기의 전역 순서가 없다**.
    - 따라서 사용자가 읽을 때 예전 상태 일부와 새로운 상태 일부를 함께 볼 수 있다.
- 한 가지 해결책은 인과성이 있는 쓰기는 동일한 파티션에서 기록되게끔 하는 방법이다. (하지만 일부 애플리케이션에서는 효율적이지 않음)

### 복제 지연을 위한 해결책

- 최종적 일관성 시스템으로 작업할 때 복제 지연이 몇 분, 몇 시간으로 증가한다면 애플리케이션이 어떻게 동작할지 생각해볼 필요가 있다.
- 사실 **복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 하는 것**이 문제 해결 방안이다.
- 애플리케이션 코드에서 DB보다 강력한 보장을 제공하는 방법이 있으나, 너무 복잡해서 잘못되기 쉽다.
- 애플리케이션 개발자가 이런 미묘한 복제 문제를 걱정하지 않고 DB를 신뢰할 수 있는 것이 좋다. → 이것이 **트랜잭션**이 있는 이유 (DB가 더 강력한 보장을 제공하는 방법)
- 단일 노드 트랜잭션에서 분산(복제되고 파티셔닝된) 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했다.
    - 트랜잭션은 성능과 가용성 측면에서 너무 비싸고
    - 확장 가능 시스템에서는 어쩔 수 없이 최종적 일관성을 사용해야 한다는 주장이 있다.


---

## 다중 리더 복제

- 리더 기반 복제의 단점
    - 리더가 하나만 존재하고 모든 쓰기가 해당 리더를 거쳐야 한다.
    - 어떤 이유로 **리더에 연결할 수 없다면 DB에 쓰기를 할 수 없게 된다**.
- **다중 리더** 설정 (Master-Master 혹은 Active-Active 복제)
    - 리더 기반 복제 모델은 **쓰기를 허용하는 노드를 여러 개** 두는 것으로 확장 가능하다.
    - 복제는 마찬가지로, 쓰기 처리를 하는 노드는 **데이터 변경을 다른 모든 노드에 전달**한다.
    - 이 설정에서 **각 리더**는 동시에 **다른 리더의 팔로워 역할**을 수행한다.

### 다중 리더 복제의 사용 사례

- 다중 리더 설정은 단일 데이터센터 환경에선 이점이 크지 않으며 다음과 같은 상황에서 사용하는 것이 합리적이다.
- **다중 데이터센터 운영**
    - 단일 리더 환경에서 여러 데이터센터에 복제 서버가 존재하는 경우, **모든 쓰기는 리더가 있는 데이터센터를 거쳐야** 한다.
    - 이 경우 각 데이터센터마다 리더를 두면, **데이터센터 내에선 보통 리더-팔로워 복제**를 사용하고, **데이터센터 간에는 리더끼리 변경 사항을 복제**한다.
    - **빠른 성능** : 단일 리더보다 데이터센터 간 복제가 적고 이로 인한 지연이 적으므로 사용자가 인지하는 성능이 더 좋다.
    - **데이터센터 중단 내성** : 데이터센터 장애 시, 단일 리더는 팔로워→리더 승격 작업을 거쳐야 하지만, 다중 리더는 각 데이터센터는 독립적으로 동작하고 정상화 후 복제를 따라잡는다.
    - **네트워크 문제 내성** : 다중 리더에선 데이터센터 간 일시적인 네트워크 중단에도 쓰기 처리는 진행되므로 네트워크 문제에 보다 잘 견딘다.
    - 단점 : 동일한 데이터를 두 데이터센터에서 동시에 변경할 경우 **쓰기 충돌**이 반드시 해소되어야 한다.
    - 일부 DB는 다중 리더를 기본 제공하며 MySQL의 Tungsten Replicator, PostgreSQL의 BDR, Oracle의 GoldenGate처럼 외부에서 구현한 도구를 사용하기도 한다.
- **오프라인 작업을 하는 클라이언트**
    - 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우에 다중 리더 복제가 적절하다.
    - 예시) 휴대전화, 노트북 디바이스의 캘린더 앱
        - 읽기 요청 : 인터넷 연결과 상관없이 언제든 회의를 볼 수 있어야 한다.
        - 쓰기 요청 : 언제라도 새로운 회의에 참가할 수 있어야 한다.
        - 오프라인 상태에서 데이터를 변경하면 나중에 온라인이 되었을 때 서버 및 다른 디바이스와 동기화해야 한다.
    - 각 디바이스에는 **리더처럼 동작하는 로컬 데이터베이스**가 존재해야 한다. (오프라인 시 쓰기 요청을 기록할 용도)
    - 각 디바이스에 대해 다중 리더 복제를 **비동기 방식**으로 수행하는 프로세스가 필요하다.
    - 아키텍처 관점에서 이 설정은 데이터센터(=디바이스) 간 다중 리더 복제와 동일하다.
    - 디바이스 간 네트워크 연결은 극히 신뢰할 수 없으며 다중 리더 복제는 올바르게 동작하기가 까다롭다.
- **협업 편집**
    - 실시간 협업 편집 애플리케이션 : 여러 사람이 동시에 문서를 편집할 수 있다. (구글 독스)
    - 한 사용자가 문서를 편집할 때 **변경 내용을 즉시 로컬 복제 서버에 적용**하고 나서 동일 문서를 편집하는 **다른 사용자와 서버에 비동기 방식으로 복제**한다.
    - 편집 충돌이 없으려면 편집 전에 사용자가 잠금을 얻어야 한다. (리더에서 트랜잭션을 사용하는 단일 리더 복제와 동일)
        - → 더 빠른 협업을 위해 변경 단위를 매우 작게(e.g. 단일 키 입력) 해서 잠금을 피할 수 있다.
        - 그러나 충돌 해소가 필요한 경우를 포함해 다중 리더 복제에서 발생하는 모든 문제를 야기할 수 있다.

### 쓰기 충돌 다루기

- 다중 리더 복제의 가장 큰 문제는 단일 리더 DB에는 없는 **쓰기 충돌**이 발생한다는 점이다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/822674b1-a03a-45da-b5f4-039141a1bb12)

- **동기 대 비동기 충돌 감지**
    - 단일 리더 DB에선 첫 번째 쓰기가 완료될 때까지 두 번째 쓰기를 차단해 기다리게 하거나 두 번째 쓰기 트랜잭션을 중단해 사용자가 재시도하도록 한다.
    - 반면, 다중 리더에선 두 쓰기는 **모두 성공**하며 이후에 **비동기**로만 감지한다.
    - 이론적으론 충돌 감지를 **동기식**으로 할 수 있으나, 다중 리더 복제의 장점인 “각 복제 서버가 독립적으로 쓰기를 허용”을 잃게 된다.
- **충돌 회피**
    - 충돌을 처리하는 가장 간단한 전략은 충돌을 회피하는 것이다. (자주 권장되는 방법)
    - 특정 레코드의 모든 쓰기가 **동일한 리더**를 거치도록 애플리케이션이 보장하면 충돌은 발생 안 한다.
        - e.g. 특정 사용자의 요청을 동일한 데이터센터로 항상 라우팅하고 데이터센터 내 리더를 사용해 읽기와 쓰기를 하도록 보장한다. → **한 사용자 관점에서 단일 리더 구성**과 같다.
    - 한계점 : 데이터센터 고장, 사용자 위치 변경 등으로 트래픽을 다른 데이터센터로 다시 라우팅하게 되면 지정된 리더를 변경해야 하고 이 때 충돌 회피가 실패한다.
- **일관된 상태 수렴**
    - **쓰기 일관성**
        - 쓰기 순서가 순차적인 단일 리더 구성에서 동일한 필드를 여러 번 갱신하면 마지막 쓰기가 필드의 최종 값으로 결정된다. → **일관성 있는 DB 상태**
        - 쓰기 순서가 명확하지 않은 다중 리더 구성에서 단순하게 각 복제 서버가 쓰기를 본 순서대로 적용하면 각 복제 서버 별로 최종 값이 달라진다. → **일관성 없는 DB 상태**
    - 모든 복제 서버가 최종적으로 동일한 값(일관성)을 가지도록 보장하기 위해 **수렴(convergent)** 방식으로 충돌을 해소해야 한다.
    - 수렴 충돌 해소를 달성하는 방법
        - **최종 쓰기 승리(last write wins; LWW)**
            - 각 쓰기에 고유 ID를 부여하고 가장 높은 ID를 가진 쓰기를 고른다. (다른 쓰기는 버림)
            - 대중적이지만 데이터 유실 위험이 있다.
        - **복제 서버 우선 순위 방식**
            - 각 복제 서버에 고유 ID를 부여하고 “높은 숫자의 복제 서버에서 생긴 쓰기”를 “낮은 숫자의 복제 서버에서 생긴 쓰기”보다 항상 우선적어로 적용한다.
            - 마찬가지로 데이터 유실 가능성이 있다.
        - **어떻게든 값을 병합**
            - 사전 순으로 값을 정렬한 후 연결하는 등의 방식 (”B”, “C” 값을 “B/C”와 같이 병합)
        - **명시적 데이터 구조에 충돌 기록**
            - 모든 정보를 보존하고 나중에 충돌을 해소하는 애플리케이션 코드를 작성하는 방식
- **사용자 정의 충돌 해소 로직**
    - 가장 적합한 충돌 해소 방법은 애플리케이션에 따라 다르므로 대부분의 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직을 작성한다.
    - 쓰기 수행 중
        - 충돌을 감지하자마자 충돌 핸들러를 호출한다.
        - 핸들러는 일반적으로 사용자에게 충돌 내용을 표시하지 않는다.
        - 백그라운드 프로세스에서 빠르게 실행돼야 한다.
    - 읽기 수행 중
        - 충돌을 감지하면 모든 충돌 쓰기를 저장한다.
        - 다음 번 읽기 때 여러 버전의 데이터를 반환한다.
        - 애플리케이션은 사용자에게 충돌 내용을 보여주거나 **자동으로 충돌을 해소**하고 해소 결과를 다시 DB에 기록한다.
    - 충돌 해소는 보통 전체 트랜잭션이 아니라 개별 로우, 문서 수준에서 적용된다.
    - **자동 충돌 해소 로직**
        - **충돌 없는 복제 데이터타입(conflict-free replicated datatype; CRDT)**
            - set, map, 정렬 목록, 카운터 등을 사용해 동시에 여러 사용자가 편집 가능하고 합리적으로 충돌을 자동 해소한다.
        - **병합 가능한 영속 데이터 구조(mergeable persistent data structure)**
            - git 버전 제어 시스템처럼 명시적으로 히스토리를 추적하고 삼중 병합 함수를 사용한다.
        - **운영 변환(operational transformation)**
            - 구글 독스 같은 협업 편집 애플리케이션에서 사용하는 충돌 해소 알고리즘
- **충돌은 무엇인가?**
    - 충돌이 명백한 경우 : 동일한 레코드의 동일한 필드를 동시에 수정해 두 개의 다른 값으로 설정
    - 감지하기 어려운 충돌 : 회의실 예약 시스템에서 동일한 두 예약이 각기 다른 리더 이뤄짐

### 다중 리더 복제 토폴로지

- **복제 토폴로지** : 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로
    - 전체 연결(all-to-all)
    - 원형 토폴로지(circular topology)
    - 별 모양 토폴로지
    
    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/9102c5f2-caa6-402f-8f6f-92131b9f7f31)
    
- 원형과 별 모양 토폴로지
    - 쓰기가 모든 복제 서버에 도달하기 전에 여러 노드를 거쳐야 한다.
    - **무한 복제 루프**를 방지하기 위해 각 쓰기는 거치는 모든 노드의 식별자가 태깅된다. (중복 쓰기 무시)
    - 한 노드에서 장애가 발생하면 복구 전까진 통신을 할 수 없다. (**단일 장애점; single point of failure**)
    - 따라서 단일 장애점을 피할 수 있는 **전체 연결과 같은 토폴로지의 내결함성이 훨씬 더 좋다**.
- 전체 연결 토폴로지
    - 네트워크 혼잡 등으로 일부 복제 메시지가 다른 메시지를 추월할 수 있다는 문제점이 있다.
    
    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/fb01f41b-e933-4a8a-901a-bfb40512d86f)
    
    - 앞서 배운 “일관된 순서로 읽기”에서 본 **인과성의 문제**에 해당한다.
    - 리더 2에 전달되는 두 복제 메시지는 순서가 반대로 왔어야 했지만 네트워크 문제로 위 처럼 인과가 반대인 순서로 전달될 수 있다.
        - 갱신 전 실행됐어야 할 “삽입”이 나중에 도착
        - 리더2 관점에선 “DB에 없는 로우의 갱신”이 먼저 도착
    - 이런 이벤트를 올바르게 정렬하려면 **버전 벡터(version vector)** 기법을 사용할 수 있다.
    - **많은 다중 리더 복제 시스템에서 충돌 감지 기법이 제대로 구현되지 않았다**.
        - PostgreSQL의 BDR은 쓰기의 인과적 순서를 제공하지 않는다.
        - MySQL의 Tungsten Replicator는 충돌을 감지하기 위한 시도조차 하지 않는다.
        - 따라서 다중 리더 복제 시스템을 사용하려면 이런 문제를 인지하고 철저하게 테스트하여 믿을 만한 보장을 제공하는지 확인해야 한다.

## 리더 없는 복제

- 일부 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받는다.
- 이런 종류의 데이터베이스를 **다이나모(Dynamo) 스타일**이라 한다.
    - 리악, 카산드라, 볼드모트는 아마존 다이나모 시스템에서 영감을 얻은 리더 없는 복제 모델을 사용
- coordinator node가 클라이언트를 대신해 여러 복제 서버에 쓰기를 전송해주는 경우도 있다.
    - 리더 방식과 달리, coordinator node는 특정 순서로 쓰기를 수행하지 않는다.

### 노드가 다운됐을 때 데이터베이스에 쓰기

- 리더 기반 설정에선 복제 서버 중 하나가 다운되면 쓰기 처리를 계속하기 위해 장애 복구를 실행해야 한다.
- 반면 리더 없는 설정에선 **장애 복구가 필요하지 않다**.
    - 쓰기
        - 클라이언트는 쓰기를 모든 복제 서버에 병렬로 전송한다.
        - 일정 수 만큼의 서버가 쓰기를 확인하면 쓰기가 성공한 것으로 간주한다. (놓친 쓰기는 단순히 무시)
        - 쓰기 동안 사용할 수 없었다가 다시 온라인이 된 노드에선 읽기 요청 시 **오래된(outdated)** 값 반환
    - 읽기
        - 클라이언트는 읽기 요청을 병렬로 여러 노드에 전송한다.
        - 응답으로 여러 노드에서 최신 값, 오래된(outdated) 값을 받을 수 있다.
        - 버전 숫자를 사용해 어떤 값이 최신 내용인지 결정하므로 오래된 값을 읽는 문제를 해결할 수 있다.
- **읽기 복구와 안티 엔트로피**
    - 복제 계획은 최종적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야 한다.
    - 다이나모 스타일 데이터스토어는 이를 위해 두 가지 메커니즘을 주로 사용한다. (모든 시스템이 두 가지를 모두 구현하지는 않음)
    - **읽기 복구**
        - 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다.
        - 읽기 과정에서 오래된 값을 반환한 노드에는 새로운 값을 다시 기록해준다.
        - 이 접근 방식은 값을 자주 읽는 상황에 적합하다.
    - **안티 엔트로피 처리**
        - 추가적인 백그라운드 프로세스가 복제 서버 간 데이터 차이를 지속적으로 찾아, 누락된 데이터를 하나의 복제 서버에서 다른 복제 서버로 복사한다.
        - 특정 순서로 쓰기를 복사하기 때문에 데이터 복사에는 상당한 지연이 있을 수 있다.
- **읽기와 쓰기를 위한 정족수**
    - `n` : 복제 서버의 개수
    - `w` : **정족수 쓰기.** 모든 쓰기는 w개의 노드에서 성공해야 쓰기가 확정된다.
        - 즉, 쓰기가 성공했다고 간주하려면 n개의 노드 중 w개의 노드 성공을 확인할 때까지 기다려야 한다.
    - `r` : **정족수 읽기.** 모든 읽기는 최소한 r개의 노드에 질의해야 한다.
        - 즉, 읽기가 성공했다고 간주하려면 n개의 노드 중 r개의 노드 성공을 확인할 때까지 기다려야 한다.
    - 일반적으로 n은 홀수로 하고 `w = r = (n + 1) / 2` 로 설정한다.
    - 정족수 조건이 `w + r > n` 이면 다음과 같이 사용 불가능한 노드를 용인한다.
        - `w < n` 이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.
        - `r < n` 이면 노드 하나를 사용할 수 없어도 여전히 읽기를 처리할 수 있다.
        - e.g. `n = 3`, `w = r = 2` 이면 사용 불가능한 노드 1개를 용인한다.
    
    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/40d52de3-bfd3-4c45-b5cf-7769a22dee95)
    
    - 필요한 w, r개 노드보다 사용 가능한 노드 수가 적다면 쓰기나 읽기는 에러를 반환한다.
    - (참고) [Zookeeper의 majority quorums](https://www.cloudkarafka.com/blog/cloudkarafka-how-many-zookeepers-in-a-cluster.html)

### 정족수 일관성의 한계

- `w + r > n` 이 되면 일반적으로 모든 읽기는 키의 최신 값을 반환할 것을 기대한다.
    - 그림 5-11과 같이 쓰기 노드 셋과 읽기 노드 셋이 겹치기 때문
    - 즉, 읽은 노드 중 최신 값을 가진(쓰기가 성공한) 노드가 하나 이상 있어야 한다.
- 보통 `w`, `r` 의 값으로 노드의 과반수(n/2 초과)를 선택한다.
    - 이유는 n/2까지 노드 장애를 허용해도 `w + r > n` 이 보장되기 때문
    - 이렇게 분산 알고리즘 설계에서 어느 정도 유연성을 허용한다.
- 정족수 조건이 충족되지 않는 `w + r ≤ n` 이 되게끔 설정할 수도 있다.
    - 이 경우, 읽기와 쓰기 전송 시 성공에 필요한 확인 응답의 수는 더 적다.
- `w`, `r` 이 **작을 수록 오래된(outdated) 값을 읽을 확률이 높아진다**.
    - 최신 값을 가진 노드가 읽을 노드에 포함되지 않을 가능성이 높기 때문
    - 응답할 수 있는 복제 서버 수가 `w`, `r` 보다 적으면 DB는 쓰기나 읽기가 불가능해진다.
- `w + r > n` 인 경우에도 outdated 값을 반환하는 에지 케이스가 존재한다.
    - 느슨한 정족수를 사용한다면 r개의 노드와 w개의 노드가 겹치는 것이 보장되지 않는다.
    - 두 개의 쓰기가 동시에 발생하면 순서가 분명하지 않게 된다. → 동시 쓰기를 합치는 방법밖에 없다.
    - 클라이언트가 **읽기, 쓰기를 동시에 수행하면 읽기가 outdated 값을 반환할 가능성이 있다**. (쓰기가 일부 노드에만 반영되어서)
    - 쓰기에 성공한 서버가 w개 보다 적어 **쓰기 실패하더라도 일부 성공한 노드에선 롤백하지 않는다**. → 읽기에 본 쓰기 값이 반환될 가능성이 있다.
    - 기타 등등..
- 매개변수 `w` 와 `r` 로 **outdated 값을 읽는 확률은 조정**할 수 있지만 이를 **절대적으로 보장할 수는 없다**.
    - 견고한 보장은 일반적으로 **트랜잭션**이나 **합의**가 필요하다.
- **최신성 모니터링**
    - 운영 관점에서 DB가 최신 결과를 반환하는지 여부를 모니터링하는 것은 중요하다.
        - 복제가 명확히 뒤처진다면 원인을 조사할 수 있어야 하므로
    - 리더 기반 복제에선 일반적으로 DB가 복제 지연에 대한 지표를 노출한다.
    - 하지만 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 더 어렵다.
        - 특히 **안티 엔트로피**를 사용하지 않고 **읽기 복구**만 사용하는 경우, 자주 읽히지 않는 값은 아주 오래된 값일 수도 있다.
    - 최종적 일관성은 모호한 보장이지만 운용성을 위해 “최종적” 개념을 정량화할 수 있어야 한다. (시스템에 맞게 최신성 모니터링을 강구해라)

### 느슨한 정족수와 암시된 핸드오프

- 정족수는 내결함성이 없다.
    - 네트워크 중단 등 상황에서는 응답 가능한 노드 수가 w나 r 보다 적을 가능성이 있다.
- 네트워크 장애 상황에서 클라이언트는 정족수 구성에 들어가지 않는 노드에 연결될 가능성이 있다. → 이 경우 아래와 같은 트레이드오프에 직면한다.
    - w이나 r 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환할 것인가?
    - 아니면 일단 쓰기를 받아들이고, “(값이 저장되는) n개 노드에 속하지는 않지만 연결할 수 있는 노드”에 기록할 것인가?
- 위에서 후자를 **느슨한 정족수**라 부른다.
    - 쓰기와 읽기는 여전히 w, r의 성공 응답이 필요하지만
    - 값을 위해 지정된 n개의 “홈” 노드에 없는 노드가 포함될 수 있다.
    - e.g. 내 집 문이 잠겨 들어갈 수 없다면 이웃집 문을 두드려 소파에 잠시 머무를 수 있는지 묻는 상황
- 네트워크 장애 상황이 해제되면 한 노드가 일시적으로 수용한 모든 쓰기를 해당 “홈” 노드에 전송한다.
    - 이를 **암시된 핸드오프**라 부른다.
    - e.g. 내 집 열쇠를 찾으면 이웃이 정중히 소파에서 일어나 집으로 돌아가라고 요청하는 상황
- 느슨한 정족수는 쓰기 가용성을 높이는데 유용하다.
    - 최신 값이 일시적으로 n 이외의 노드에 기록될 수 있으므로 `w + r > n` 인 경우라도 키의 최신 값을 읽는다고 보장하지 않는다.
- 느슨한 정족수는 다이나모 구현에서 선택사항이다. 카산드라, 볼드모트에선 기본적으로 비활성화되어 있다.
- **다중 데이터센터 운영**
    - 리더 없는 복제도 “동시 쓰기 충돌”, “네트워크 중단”, “지연 시간 급증”을 허용하므로 다중 데이터센터 운영에 적합하다.
    - 각 데이터센터마다 n개의 복제 서버 중 몇 개를 보유할지를 지정한다.
    - 클라이언트의 쓰기는 데이터센터 상관없이 모든 복제 서버에 전송되지만
    - 보통 로컬 데이터센터 안에서 정족수 노드의 확인 응답을 기다리기 때문에 **데이터센터 간 연결의 지연과 중단에 영향을 받지 않는다**.

### 동시 쓰기 감지

- 다이나모 스타일 DB는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하므로 엄격한 정족수를 사용하더라도 충돌이 발생한다.
    
    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/c548288c-5413-4bf1-9eee-a0e3aa6f73e2)
    
- 예시 상황
    - 노드 1은 A로부터 쓰기를 받지만 장애로 B로부터 쓰기를 받지 못 함
    - 노드 2는 A로부터 쓰기를 먼저 받고 그 다음 B로부터 쓰기를 받음
    - 노드 3은 B로부터 쓰기를 먼저 받고 그 다음 A로부터 쓰기를 받음
    - 쓰기 요청 마다 키의 값을 덮어쓴다면 마지막 get 요청처럼 **노드들은 영구적으로 일관성이 깨진다**.
- 최종적인 일관성 달성을 위해 복제본들은 동일한 값을 가져야 하지만, 대부분의 구현은 이를 자동으로 처리하지 못 한다.
- “쓰기 충돌 다루기”에서 다룬 충돌 해소 기법을 더 자세히 알아보자
- **최종 쓰기 승리(동시 쓰기 버리기)**
    - 최종적으로 값을 수렴하기 위한 접근 방식 중 하나는 각 복제본이 가진 “예전” 값을 버리고 가장 “최신” 값으로 덮어쓰는 것이다.
    - **최종 쓰기 승리(LWW)** : 쓰기에 타임스탬프를 붙여 가장 최신 쓰기만 선택하고 예전 타임스탬프 값의 쓰기는 무시한다.
    - 최종적 수렴 달성이 목표지만 **지속성을 희생**한다. (쓰기 중 하나만 남고 다른 쓰기는 조용히 무시)
    - 손실 데이터를 허용하지 않는 경우엔 LWW이 충돌 해소에 적합하지 않다
    - LWW로 DB를 안전하게 사용하는 유일한 방법은, **키를 한 번만 쓰고 이후에는 불변 값으로 다루는 것**
        - 같은 키를 동시에 갱신하는 상황을 방지해야 한다.
        - e.g. 키로 UUID를 사용해 모든 쓰기 작업에 고유한 키를 부여한다.
- **“이전 발생” 관계와 동시성**
    - 두 작업 A, B가 동시에 수행되었는지 여부를 어떻게 결정할까?
    - B가 A에 대해 알거나 A에 의존적이거나 어떤 식으로든 A를 기반으로 한다면 A는 B의 **이전 발생(happens-before)** 이다. (인과성이 있다.)
    - 작업이 다른 작업보다 먼저 발생하지 않으면 (어느 작업도 다른 상대 작업을 알지 못 하면) 단순히 **동시 작업**이라 말한다. → 동시성의 의미를 정의하는 핵심
    - 분산 시스템에서 시간으로 동시성을 정의하는 것은 쉽지 않고, 애초에 정확한 시각은 동시성 정의에 중요하지 않다.
    - 즉, 작업 A와 B가 있다면 세 가지 가능성이 있다.
        - B 이전에 A가 발생
        - A 이전에 B가 발생
        - A, B가 동시에 발생
    - 이전 발생 관계라면 나중 작업이 이전 작업을 덮어 쓸 수 있지만, 동시 작업 관계라면 충돌을 해소해야 함
- **이전 발생 관계 파악하기**
    - 두 작업이 동시에 발생했는지 또는 하나가 이전에 발생했는지 여부를 결정하는 알고리즘
    - 서버는 버전 번호를 보고 두 작업이 동시에 수행됐는지 여부를 결정할 수 있다.
    - 알고리즘 동작 원리
        - 서버는 모든 키에 대한 버전 번호를 유지하고, 키를 기록할 때마다 버전 번호를 증가시킨다.
        - 클라이언트가 키를 읽을 때 서버는 최신 버전 뿐만 아니라, 덮어쓰지 않은 모든 값을 반환한다.
        - 클라이언트는 쓰기 전에 키를 읽어야 한다.
        - 클라이언트가 키를 기록할 때 이전 읽기의 버전 번호를 포함해야 하고, 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다. (쓰기 요청은 현재 모든 값을 반환)
        - 서버는 특정 버전 번호를 가진 쓰기를 받으면 해당 버전 이하 모든 값을 덮어쓸 수 있다.
        - 하지만 이보다 높은 버전 번호의 모든 값은 유지해야 한다.
    - 쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있다.
    - 버전 번호를 포함하지 않은 쓰기는 다른 쓰기와 동시에 수행된 것이므로 아무것도 덮어쓰지 않는다.
- **동시에 쓴 값 병합**
    - 이 알고리즘에선 클라이언트가 추가적인 작업을 수행해야 한다.
    - 여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야 한다.
    - 리악에선 이런 동시 값을 **형제(sibling)** 값이라 부른다.
    - 버전 번호, 타임스탬프 기반으로 하나의 값을 선택하는 방법(최종 쓰기 승리)에선 데이터 손실이 생길 수 있다.
    - 병합은 합집합 등으로 이러한 동시에 쓴 값들을 모두 나타낸다.
    - 값의 추가 외에 삭제도 할 수 있게 하려면 병합할 때 제거됐음을 나타내는 **툼스톤** 삭제 표시를 버전 번호에 표시해야 한다.
    - 애플리케이션 코드의 형제 병합은 복잡하고 오류가 발생하기 쉽다.
- **버전 벡터**
    - 버전 번호를 사용하는 경우에서 다중 복제본이 있지만 리더가 없는 경우의 알고리즘
    - **키**당 버전 번호 뿐만 아니라 **복제본**당 버전 번호도 사용해야 한다.
    - 모든 복제본의 버전 번호 모음을 버전 벡터(version vector) 라 부른다.

## 정리

- 복제는 다양한 용도로 사용할 수 있다.
    - **고가용성** : 장비, 데이터센터 장애에도 시스템이 동작하도록
    - **연결이 끊긴 작업** : 네트워크 중단에도 애플리케이션이 동작하도록
    - **지연 시간** : 사용자와 지리적으로 가까이에 데이터 복제본을 배치
    - **확장성** : 단일 장비에서 다룰 수 있는 양보다 더 많은 양의 읽기 작업 처리 가능
- 복제는 동일한 데이터의 복사본을 여러 장비에 유지하는 것이 목표이지만 이는 매우 까다로운 문제임
- 복제에 대한 세 가지 주요 접근 방법
    - **단일 리더 복제** : 모든 쓰기는 단일 노드(리더)를 거치고 읽기는 모든 복제 서버에서 수행한다.
    - **다중 리더 복제** : 쓰기는 여러 리더 노드 중 가능한 곳에 전송되고, 리더는 데이터 변경을 다른 리더와 모든 팔로워에 전송한다.
    - **리더 없는 복제** : 클라이언트는 각 쓰기를 여러 노드에 동시에 전송하고, 읽기 또한 병렬로 여러 노드에서 읽어 outdated 데이터를 감지하여 바로잡는다.
    - 단일 리더 복제는 이해하기 쉽고, 충돌 해소에 대한 우려가 없어서 널리 사용된다.
    - 다중 리더 복제와 리더 없는 복제는 결함 노드, 네트워크 중단, 지연 시간 급증이 있는 상황에서 견고하다.
        - 하지만 설명하기 어렵고 일관성이 거의 보장되지 않는다는 단점이 있다.
- 복제는 동기 또는 비동기로 이뤄진다.
    - 비동기 복제는 시스템이 원활히 동작할 땐 빠르다.
    - 리더가 고장나고 비동기로 갱신된 팔로워가 새로운 리더로 승격되면 최근 커밋 데이터를 잃을 수 있다.
- 복제 지연으로 인해 발생할 수 있는 이상 현상과 일부 일관성 모델
    - **쓰기 후 읽기 일관성** : 사용자가 자신이 제출한 데이터를 항상 볼 수 있어야 한다.
    - **단조 읽기** : 시간이 거꾸로 흐르는 현상을 겪지 않도록 예전 시점의 데이터를 나중에 볼 수 없어야 한다.
    - **일관된 순서로 읽기** : 인과성이 있는 상태의 데이터를 봐야 한다. 질문과 그에 대한 답을 순서에 맞게 볼 수 있어야 한다.
- 다중 리더 복제와 리더 없는 복제에 내재된 동시성 문제
    - 두 접근 방식은 여러 쓰기가 동시에 발생하는 상황을 허용하므로 충돌이 발생할 수 있다.
    - 두 작업이 동시에 발생했는지, 이전 발생 관계인지 결정하는 알고리즘들
    - 동시 갱신을 함께 병합해 충돌을 해결하는 방법
 
