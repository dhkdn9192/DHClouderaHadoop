# 06장 - 파티셔닝

- **샤딩** : 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제본만으로 부족하고 파티션으로 쪼갤 필요가 있다.
- 각 DB에서 파티션에 해당하는 것
    - MongoDB, ElasticSearch의 **샤드(Shard)**
    - HBase의 **리전(region)**
    - BigTable의 **태블릿(tablet)**
    - Cassandra, Riak의 **브이노드(vnode)**
    - Couchbase의 **브이버켓(vBucket)**
- 각 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 된다.
- 파티션은 그 자체로 작은 데이터베이스와 같다.
- 데이터 파티셔닝의 주된 이유는 **확장성**이다.
    - 각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있으므로 노드를 추가함으로써 질의 처리량을 늘릴 수 있다.

## 파티셔닝과 복제

- 보통 **복제와 파티셔닝을 함께 적용**하므로 각 레코드가 한 파티션에 속하더라도 이를 여러 다른 노드에 저장하여 **내결함성**을 보장한다.

### 키-값 데이터 파티셔닝

- 파티셔닝의 목적 : **데이터와 질의 부하를 노드 사이에 고르게 분산**시키는 것이다.
- 파티셔닝이 고르게 이뤄지지 않아 특정 파티션에 데이터 혹은 질의가 몰리는 것을 **쏠렸다(skewed)** 라고 말한다.
- **핫스팟** : 불균형하게 부하가 높은 파티션을 부르는 용어
- 핫스팟을 회피하는 방법
    - 레코드를 할당할 노드를 무작위로 선택
        - 핫스팟을 회피할 수 있는 가장 단순한 방법
        - 단점 : 읽고싶은 레코드가 어느 노드에 저장됐는지 알 수 없으므로 모든 노드에서 병렬로 질의해야 한다.
    - 키-값 데이터 모델에서 기본키로 레코드 접근
        - 위 방식보다 나은 방식으로, 모든 노드에 접근할 필요 없이 기본키로 원하는 레코드에만 접근 가능하다.

### 키 범위 기준 파티셔닝

- **키 범위 기준 파티셔닝**
    - 각 파티션은 **연속된 범위의 키들**을 갖는다.
    - 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 알 수 있다.
    - 키 범위의 크기가 반드시 모두 동일할 필요는 없다.
- 키 범위 기준 파티셔닝 전략을 사용하는 케이스
    - BigTable, HBase, RethinkDB, 2.4이전 버전의 MongoDB
- 장점
    - 각 파티션의 **키들은 정렬된 순서로 저장**되므로 **범위 스캔이 쉽다**.(SS테이블과 LSM트리 참고)
    - 키를 연쇄된 색인으로 간주하여 질의 하나로 관련 레코드들을 한 번에 읽어올 수 있다.
- 단점
    - 특정한 접근 패턴이 **핫스팟**을 유발할 수 있다.
    - 키를 timestamp로 지정하면 안 된다.
        - 쓰기 연산이 항상 동일한 파티션(가장 마지막 파티션)으로 전달되고
        - 해당 파티션만 과부화, 나머지는 유휴 상태가 된다.
    - → 이러한 문제를 해결하려면 키의 첫 번째 요소에 timestamp가 아닌 다른 요소를 넣어야 한다.

### 키의 해시값 기준 파티셔닝

- **쏠림**과 **핫스팟**을 줄이기 위해 키의 파티션을 정하는데 **해시 함수**를 사용할 수 있다.
- 좋은 해시 함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 한다.
- 파티셔닝용 해시 함수는 암호적으로 강력할 필요는 없다.
- 같은 키를 넣어도 다른 프로세스에서 다른 해시값을 반환하는 내장 해시 함수는 적합하지 않다.
    - e.g. 자바의 Object.hashCode(), 루비의 Object#hash
- 해시 함수를 적용하는 방법은, 각 파티션에 키 범위 대신 해시값 범위를 할당하고, 해시값이 속하는 파티션의 범위에 키를 할당한다. 이를 모든 키에 동일하게 적용한다.
- 이러한 기법을 일관성 해싱이라고도 부르지만 보통 **해시 파티셔닝**이라는 표현을 쓰는게 더 좋다.
- 장점
    - 키를 파티션 사이에 균일하게 분산시키는데 좋다.
- 단점
    - 키 범위 파티셔닝의 **범위 질의라는 장점을 쓸 수 없게** 된다.
    - 키 범위 파티셔닝에선 인접했던 키들이 모든 파티션에 흩어져서 정렬 순서가 유지되지 않기 때문이다.
    - 이런 단점을 보완하기 위해 **복합 기본키**를 지정할 수 있다.
- **복합 기본키**
    - 카산드라는 키 범위 기준 파티셔닝과 해시값 기준 파티셔닝 사이에서 타협하여 복합 기본키를 제공한다.
    - **키의 첫 부분에만 해싱**을 적용하여 파티션 결정에 사용하고
    - **나머지 키 부분은 데이터를 정렬하는 연쇄된 색인으로 사용**한다. (SS테이블)
    - 즉, 첫 번째 칼럼에 고정된 값을 지정하면 다른 칼럼에 대해선 범위 스캔을 실행할 수 있다.
    - e.g. SNS에서 사용자별 문서 수정 이력에 대해 복합 기본키를 (user_id, update_timestamp)로 지정할 수 있다.
        - 특정 사용자를 지정하면 해당 사용자에 대해 문서 수정 이력을 타임스탬프 순으로 정렬해서 범위스캔할 수 있다.
    - e.g. HBase에서 rowkey를 설계할 때 앞 부분에 salt값을 넣어 위와 동일한 효과를 얻을 수 있다.

### 쏠린 작업부하와 핫스팟 완화

- **해시값 기준 파티셔닝**은 핫스팟을 줄이는데 도움이 되지만 **완벽하게 핫스팟을 제거할 순 없다**.
    - 항상 동일한 키에 대해 읽고 쓰기를 수행하는 극단적인 상황에선 모든 요청이 동일한 파티션으로만 쏠리게 된다.
    - e.g. SNS에서 많은 팔로워를 가진 유명인의 작업에 대한 파티셔닝
- 현대 데이터 시스템은 크게 쏠린 작업부하를 자동으로 보정하지 못 하므로 **개발자가 애플리케이션단에서 쏠림을 완화해야** 한다.
- 간단한 해결책은 **각 키의 시작이나 끝에 임의의 숫자를 붙이는 것**이다.
- 대신 읽기를 수행할 때 **다른 키로 쪼개서 쓰여진 값들을 읽기 위한 추가적인 작업이 필요**하다.

## 파티셔닝과 보조 색인

- 보조 색인을 사용해야 하는 경우, 파티셔닝은 조금 복잡해진다.
- **보조 색인**은 보통 레코드를 유일하게 “식별”하는 용도가 아니라(이건 기본키), **특정한 값이 발생한 항목을 “검색”하는 수단**이다.
- 많은 키-값 저장소에서 구현 복잡도가 추가되는 것을 피하려고 보조 색인을 지원하지 않지만, 보조 색인은 데이터 모델링에 매우 유용하므로 리악 등 일부 저장소에선 이를 추가하기 시작했다.
- **보조 색인은 Solr나 ElasticSearch 같은 검색 서버에는 존재의 이유**다.
- 보조 색인은 파티션이 깔끔하게 대응되지 않는 문제점이 있다.
- 보조 색인이 있는 데이터베이스를 파티셔닝하는 방법으론 **문서 기반 파티셔닝**과 **용어 기반 파티셔닝** 이렇게 두 가지가 있다.

### 문서 기준 보조 색인 파티셔닝

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/28630224-5170-4942-8d25-8ca703908038)

- 각 문서는 **문서ID(document ID)** 라 부르는 고유 ID를 가지며, 데이터베이스는 이 **문서ID를 기준으로 파티셔닝**된다. → **기본키 색인**
- 각 파티션 별로 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다. → **지역 색인(local index)**
- e.g. 중고차판매 웹사이트의 DB에서 차를 빨간 색상으로 필터링할 때 각 파티션에 color 필드에 대한 보조 색인을 만들어야 한다. 보조 색인은 자신이 속한 파티션 중에서 color:red인 항목들의 문서ID(기본키)들을 반환한다.
- 단점
    - **보조 색인으로 검색 시, 모든 파티션으로 질의를 보내서 결과를 얻어야 한다**. → **스캐터/개더(scatter/gather 방법)**
    - 이러한 질의는 큰 비용이 들어가며, 파티션들에 병렬로 실행하더라도 스캐터/개더 방식은 **꼬리 지연 시간 증폭**이 발생하기 쉽다.

### 용어 기준 보조 색인 파티셔닝

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/461f6fde-c26e-4605-82ff-a868ceb99251)

- 각 파티션이 자신만의 지역 색인을 갖는 것과 반대로, 모든 파티션의 데이터를 담당하는 **전역 색인(global index)** 을 만드는 방식이다.
- 전역 색인 정보를 한 노드에만 저장하면 병목이 될 수 있으니 전역 색인 자체도 파티션이되어야 한다.
- e.g. 차를 빨간 색상으로 필터링할 때 전역 색인에서 color 필드에 대한 색인은 a부터 r까지의 글자로 시작하는 색상은 파티션0에 들어간다. 따라서 전역 색인의 파티션0에서 color:red 항목을 검색하여 빨간 색상인 모든 항목들의 기본키들을 얻는다.
- 찾고자 하는 용어(term)에 따라 색인의 파티션이 결정되므로 **용어 기준으로 파티셔닝(term-partitioned)** 됐다고 한다. (예시의 color:red가 용어)
- 용어 기준 파티셔닝의 두 가지 방식
    - 색인을 파티셔닝할 때 **용어 자체**를 사용 → **범위 스캔에 유리**하다.
    - 색인을 파티셔닝할 때 **용어의 해시값** 사용 → **부하가 좀 더 고르게 분산**된다.
- 문서 파티셔닝 색인 대비 장점
    - 읽기가 효율적이다.
    - 클라이언트는 모든 파티션에 스캐터/개더를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다. (전역 색인에서 찾아서)
- 문서 파티셔닝 색인 대비 단점
    - 전역 색인은 쓰기가 느리고 복잡하다.
    - 전역 보조 색인은 **비동기로 갱신**되는데 인프라에 결함이 생기면 반영 지연 시간이 길어질 수 있다.

## 파티션 재균형화

- 시간이 지남에 따라 장비 추가, 장애 처리 등으로 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 하는 상황이 생긴다.
- 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 **재균형화(rebalancing)** 라고 한다.
- 재균형화가 실행될 때 파티셔닝 방식과 무관하게 만족해야할 최소 요구사항
    - 재균형화 후, **부하(데이터, 읽기쓰기 요청)가 노드들에 균등하게 분배**돼야 한다.
    - 재균형화 **도중에도 데이터베이스는 읽기 쓰기가 가능해야** 한다.
    - 재균형화가 빠르게 실행되고 네트워크 및 I/O 부하를 최소화하기 위해 **필요 이상의 데이터가 옮겨져서는 안 된다**.

### 재균형화 전략

- **쓰면 안 되는 방법: 해시값에 mod n 연산을 수행**
    - 키의 해시값 기준으로 파티셔닝할 때 사용 가능한 해시값 범위를 나누고 각 범위를 한 파티션에 할당한다고 했다.
        - `0 ≤ hash(key) < b0` 이면 key를 파티션0에 할당
        - `b0 ≤ hash(key) < b1` 이면 key를 파티션1에 할당
    - 노드가 10개라면 `hash(key) mod 10` 연산으로 10개 노드에 할당할 수 있다고 생각할 수 있지만 **이렇게 하면 안 된다**.
    - mod n 방식의 문제점
        - 노드 개수 n이 바뀌면 거의 모든 키가 노드를 옮겨가야 한다.
        - 즉, scale-out 할 때 마다 데이터를 필요 이상으로 대규모로 이동시켜야 하므로 확장 구조에 맞지 않다.
- **파티션 개수 고정**
    - 위 방식은 간단하게 해결 가능하다.
    - 파티션을 노드 수보다 많이 만들고 **각 노드가 여러 개의 파티션을 할당**하는 것
    - 노드 추가와 제거
        - 새 노드는 기존 노드에서 파티션 몇 개를 뺏어 올 수 있다.
        - 노드 제거 시 위 과정을 반대로 수행한다.
    - **파티션 개수는 바뀌지 않고** 파티션에 **할당된 키도 변경되지 않으며** 파티션은 노드 사이에서 통째로 이동하기만 한다.
    - 유일한 변화는 노드에 어느 파티션이 할당되는가 뿐이다.
    - 클러스터에 성능이 다른 하드웨어가 섞여있는 경우
        - 성능 좋은 노드에 파티션을 더 할당하여 더 많은 부하를 담당하게 할 수 있다.
    - 이런 재균형화 방법을 사용하는 케이스
        - 리악, ElasticSearch, CouchBase, 볼드모트
    - 단점
        - 파티션 개수가 고정이므로 **처음 설정된 파티션 개수가 사용 가능한 노드 대수의 최대치가 된다**. (충분히 높은 값 선택해야 함)
        - 전체 데이터셋의 크기 변동이 심하면 적절한 파티션 개수를 정하기 어렵다.
        - 개별 파티션의 크기 또한, 너무 크면 재균형화 및 장애 복구 시 비용이 매우 크고, 너무 작으면 오버헤드가 커진다.
    - 정리
        - 파티션 수를 고정하여 각 **파티션의 크기**가 **데이터셋의 크기**에 비례한다.
- **동적 파티셔닝**
    - 키 범위 파티셔닝에서 고정된 파티션 경계와 개수는 불편한 요소다.
        - 파티션 경계가 잘못 지정되면 한 파티션에만 데이터가 저장되고 나머지는 텅 빌 수 있다.
        - 파티션 경계를 수동으로 재설정하는 작업은 매우 성가시다.
    - 이런 이유로 HBase, 리싱크DB는 동적 파티셔닝을 사용한다.
        - 파티션 크기가 설정된 값을 넘어서면 파티션을 둘로 쪼갠다.
        - 반대로 파티션 크기가 임계값 아래로 떨어지면 인접한 파티션과 합친다.
    - 파티션 개수 고정과 마찬가지로 각 파티션은 한 노드에 할당되고, 한 노드는 여러 파티션을 담당할 수 있다.
    - 장점
        - **파티션 개수가 전체 데이터 용량에 맞춰 조정**된다.
        - 데이터 양이 작으면 파티션 개수도 적으므로 오버헤드도 작다.
        - 데이터 양이 거대하면 개별 파티션의 크기는 설정된 최대치로 제한된다.
    - 단점
        - 빈 DB는 파티션 경계를 어디로 정해야하는지 사전 정보가 없으므로 **시작할 때는 파티션 수가 하나다.**
        - 즉, 처음 구축 시에는 **모든 쓰기 요청이 한 노드에서만 수행**되고 다른 노드들은 유휴 상태가 된다.
        - 이런 문제를 해결하기 위해 HBase, MongoDB에선 초기 파티션 집합을 설정할 수 있도록 **사전 분할(pre-splitting)** 기능을 제공한다.
    - 동적 파티셔닝은 범위 파티셔닝에만 적합한 것이 아니라 해시 파티셔닝에도 똑같이 사용할 수 있다.
    - 정리
        - 동적 파티셔닝은 파티션 분할과 병합을 통해 **개별 파티션 크기를 고정된 최솟값과 최댓값 사이로 유지**한다.
        - 즉, **파티션 개수**가 **데이터셋 크기**에 비례한다.
- **노드 비례 파티셔닝**
    - 위 두 방식에선 파티션의 크기 혹은 개수가 ”전체 데이터셋 크기“에 비례한다.
    - 노드 비례 파티셔닝은 **파티션 개수가 ”노드 수“에 비례**하도록 한다.
    - 즉 **노드당 할당되는 파티션 개수를 고정**한다.
    - 노드 수에 따른 파티션 변화
        - 노드 수 변화 X → 각 파티션 크기가 데이터셋 크기에 비례해서 증가
        - 노드 수를 늘리면 → 각 파티션 크기는 다시 작아진다.
    - 노드 추가 과정
        - 파티션을 무작위로 선택해 분할한다.
        - 분할된 파티션의 절반을 새 노드에 할당한다.
    - 장점
        - 일반적으로 데이터셋이 클수록 노드도 많이 필요하므로 이 방법에선 **각 파티션 크기도 상당히 안정적으로 유지**된다.
    - 단점
        - 노드 추가 시 분할할 파티션을 무작위로 선택하므로 **균등하지 않은 분할**이 생길 수 있다. → 여러 파티션에 대해 평균적으로 보면 새 노드는 기존 노드들의 부하에서 균등한 몫을 할당받음
        - 이런 문제를 해결하기 위해 카산드라 3.0에는 불균등한 분할을 회피할 수 있는 대안적인 재균형화 알고리즘이 추가됐다.

### 운영: 자동 재균형화와 수동 재균형화

- 재균형화는 자동으로 수행될까, 아니면 수동으로 실행해야 할까?
- 완전 자동 재균형화
    - 관리자의 개입이 전혀 없이 시스템이 자동으로 언제 파티션을 어느 노드 사이에 이동할지 결정한다.
    - 일상적인 유지보수가 편리해지지만 예측하기 어렵기도 하다.
    - 자동화가 자동 장애 감지와 조합되면 연쇄 장애 등 위험한 상황이 발생할 가능성이 커진다.
- 완전 수동 재균형화
    - 관리자가 명시적으로 파티션을 노드에 할당하도록 설정하고, 관리자가 재설정할 때만 파티션 할당이 변경된다.
    - 운영상 예상치 못한 일을 방지하기 위해 사람이 개입하는게 좋을 수도 있다.
- 중간 지점
    - 자동으로 파티션 할당을 제안하지만 반영되려면 관리자가 확정해야 한다.
    - CouchBase, 리악, 볼드모드가 이에 해당

## 요청 라우팅

- 파티션은 재균형화되면서 할당되는 노드가 바뀐다.
- 클라이언트가 요청을 보낼 때, 어느 노드로 접속해야 한느지 어떻게 알 수 있을까?
- 이러한 문제는 일반적인 문제인 **서비스 찾기(service discovery)** 의 일종이다.
- 상위 수준에서 보면 몇 가지 접근법이 존재한다.
    1. 클라이언트가 아무 노드에 접속하게 한다(round-robin 로드밸런서 등). 해당 노드에 요청을 적용할 파티션이 있다면 거기서 처리하고, 그렇지 않으면 요청을 올바른 노드로 전달해 응답을 받아 클라이언트에게 반환한다.
    2. **파티션 인지(partition-aware) 로드밸런서**로 동작하는 **라우팅 계층**을 둔다. 클라이언트는 모든 요청을 라우팅 계층으로 보내고, 라우팅 계층에선 요청을 처리한 노드를 알아내어 해당 노드로 요청을 보낸다.
    3. 클라이언트가 중개자 없이 올바른 노드로 직접 접속한다. 클라이언트는 파티션이 어떤 노드에 할당됐는지 알고 있어야 한다.
- 많은 분산 데이터 시스템은 클러스터 메타데이터를 추적하기 위해 ZooKeeper 같은 별도의 코디네이션 서비스를 사용한다.
    - 각 노드는 zookeeper에 자신을 등록하고, zookeeper는 파티션과 노드 사이의 할당 정보를 관리한다.
    - 라우팅 계층, 파티션 인지 클라이언트 등은 zookeeper의 정보를 구독한다.
    - 파티션 소유자 변경, 노드 추가, 노드 삭제 시 zookeeper는 라우팅 계층에 알려서 라우팅 정보를 최신으로 유지하도록 한다.
- 라우팅 요청 구현 케이스
    - 링크드인의 에스프레소는 Helix로 클러스터를 관리(Helix는 ZooKeeper에 의존)
    - HBase, SolrCloud, Kafka도 파티션 할당을 추적하는데 ZooKeeper를 사용한다.
    - MongoDB는 자체적인 설정 서버(config server) 구현에 의존하고, mongos 데몬을 라우팅 계층으로 사용한다.
    - 카산드라, 리악은 가십 프로토콜(gossip protocol)을 사용해 클러스터 상태 변화를 노드 사이에 퍼뜨린다. → 복잡성을 더하지만 ZooKeeper 같은 외부 코디네이션 서비스에 의존하지 않는다.
    - CouchBase는 재균형화를 자동으로 실행하지 않아서 설계가 단순하다. 클러스터 노드로부터 변경된 라우팅 정보를 알아내는 moxi라는 라우팅 계층을 설정한다.
- 클라이언트는 라우팅 계층을 사용하거나 임의의 노드로 요청을 보낼 때도 접속할 IP 주소를 알아야 한다.
    - IP 주소는 파티션 정보만큼 자주 바뀌지 않으므로 IP 주소를 찾는데는 보통 DNS를 쓰는 것으로 충분하다.

### 병렬 질의 실행

- 분석용으로 자주 사용되는 대규모 병렬 처리(massively parallel processing, MPP) 관계형 데이터베이스는 훨씬 더 복잡한 종류의 질의를 지원한다.
- join, filtering, grouping, aggregation 연산 등
- MPP 질의 최적화기는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하여 여러 노드에서 병렬적으로 실행할 수 있다.

## 정리

- 대용량 데이터셋을 작은 데이터셋으로 파티셔닝하는 방법을 살펴봤다.
    - 데이터가 너무 많아져서 장비 한 대로 처리 불가능하면 파티셔닝이 필요하다.
- 파티셔닝의 목적
    - **핫스팟이 생기지 않게** 하면서 데이터와 **질의 부하를 여러 장비에 균일하게 분배**하는 것
    - 그러려면 **데이터에 적합한 파티셔닝 방식**을 선택해야 하고
    - 클러스터에 노드 추가, 제거 시 **파티션 재균형화**를 실행해야 한다.
- 두 가지 주요 파티셔닝 기법
    - **키 범위 파티셔닝**
        - 키가 정렬돼 있고 각 파티션은 설정된 범위의 모든 키를 담당한다.
        - **범위 질의에 효율적**이지만
        - 정렬 순서가 가까운 키에 자주 접근하면 핫스팟이 생길 수 있다.
        - 보통 한 파티션이 **너무 커지면 키 범위를 둘로 쪼개 동적으로 재균형화**한다. (→ **동적 파티셔닝**)
    - **해시 파티셔닝**
        - 각 키에 해시함수를 적용하고, **각 파티션은 특정 범위의 해시값을 담당**한다.
        - 키 순서가 보장되지 않아 **범위 질의에 비효율적**이지만
        - **부하를 더욱 균일하게 분산**할 수 있다.
        - 보통 **파티션 개수를 고정**하고 **각 노드에 여러 파티션을 할당**하며, 노드 추가 및 제거 시 **파티션을 통째로 노드 사이에서 이동**시킨다. (→ **파티션 개수 고정**)
        - 동적 파티셔닝을 쓸 수도 있다.
    - 위 두 방식을 섞어서 키의 일부분은 파티션 식별용, 나머지 부분은 정렬 순서용으로 만든 **복합 키**를 사용할 수도 있다.
- 보조 색인도 파티셔닝이 필요하며 두 가지 방법이 있다.
    - **문서 파티셔닝 색인 (지역 색인)**
        - 기본키와 값이 저장된 각 파티션에 보조 색인을 저장한다.
        - 쓰기 : 파티션 하나만 갱신하면 된다.
        - 읽기 : 보조 색인을 읽으려면 **모든 파티션에 걸쳐 스캐터/개더를 실행**해야 한다.
    - **용어 파티셔닝 색인 (전역 색인)**
        - 색인된 값을 사용해서 보조 색인을 별도로 파티셔닝한다. (보조 색인 항목은 모든 파티션에 있는 레코드를 포함할 수도 있음)
        - 쓰기 : 보조 색인 여러 개를 갱신해야 한다.
        - 읽기 : 단일 파티션에서 실행될 수 있다.
