# 07장 - 트랜잭션

- 데이터 시스템에서 발생할 수 있는 여러 문제들
    - 데이터베이스 S/W, H/W는 언제든 실패할 수 있다.
    - 네트워크가 끊기면 애플리케이션-DB 연결이 끊기거나 DB 노드간 통신이 끊어질 수 있다.
    - 여러 클라이언트가 동시에 DB에 쓰기를 수행하여 다른 이가 쓴 내용을 덮어쓸 수 있다.
    - 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- **트랜잭션**이란
    - 수십년간 위와 같은 문제들을 단순화하는 메커니즘으로 채택돼 왔다.
    - 트랜잭션은 **여러 읽기, 쓰기를 하나의 논리적 단위로 묶어 하나의 연산으로 실행**한다.
    - 트랜잭션은 **전체**가 성공(**커밋**)하거나 실패(**abort, 롤백**)하므로 실패하더라도 **부분적인 실패가 없고** 안전하게 재시도할 수 있다.
- **안전성 보장(safety guarantee)**
    - 트랜잭션은 DB에 접속하는 애플리케이션에서 **프로그래밍 모델을 단순화**하려는 목적으로 만든 것
    - 트랜잭션을 사용함으로써 애플리케이션에선 어느 정도 **잠재적인 오류 시나리오와 동시성 문제를 무시**할 수 있다.
- 트랜잭션이 모든 애플리케이션에서 필요한 것은 아니며, 오히려 트랜잭션적인 보장을 완화하거나 쓰지 않는 것이 이득인 경우도 있다.
- 본 장에서 다룰 부분들
    - 동시성 제어
    - 다양한 종류의 경쟁 조건
    - 데이터베이스에서 커밋 후 읽기(read committed), 스냅숏 격리(snapshot isolation), 직렬성(serializability) 등의 격리 수준 구현

## 애매모호한 트랜잭션의 개념

- 현대의 거의 모든 관계형 DB 및 일부 비관계형 DB는 트랜잭션을 지원한다.
- 비관계형(NoSQL) DB가 발전하며 관계형 DB의 여러 이슈를 개선함에 따라 새로운 세대의 DB 중 다수는 트랜잭션을 포기하거나 약하게 보장하고 있다.
- 트랜잭션은 확장성의 안티테제이며 대규모 시스템에서 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야 한다는 믿음이 널리 퍼졌다.
- 그러나 진실은 단순하지 않으며 당연히 트랜잭션의 이점과 한계, 트레이드오프를 이해해야 한다.

### ACID의 의미

- 현실에선 데이터베이스마다 ACID 구현이 제각각으로 모호하며 거의 마케팅 용어가 되어버렸다.
- **원자성(Atomicity)**
    - 시스템은 연산을 실행하기 전과 후의 상태에만 있을 수 있으며 그 중간 상태엔 머물 수 없다.
    - 원자성은 여러 쓰기 작업 중 일부만 처리된 후 결함이 생기면 무슨 일이 일어나는지 설명한다.
        - 결함 때문에 완료(커밋)될 수 없다면 abort되고 DB는 이 트랜잭션에서 지금까지 실행한 쓰기를 취소해야한다.
        - 원자성은 **변경 도중 오류가 발생할 경우의 문제를 단순하게** 만들어주어 **안전하게 재시도**할 수 있게 해준다.
    - 반면, 원자성은 **동시성과는 관련이 없다**.
        - 원자성은 여러 프로세스가 동시에 같은 데이터에 접근할 때 무슨 일이 생기는지 설명하지 않는다.
        - 이러한 문제는 격리성(Isolation)에서 다룬다.
    - 즉, 원자성의 핵심은 **오류가 생겼을 때 트랜잭션을 abort하고 해당 트랜잭션에서 기록한 모든 내용을 취소**한다는 것이다.
- **일관성(Consistency)**
    - 일관성이란 단어는 다양한 의미로 사용되나, ACID의 일관성은 **항상 진실이어야 하는**, 데이터에 관한 **불변식(invariant)** 을 의미한다.
        - e.g. 회계 시스템에서 모든 계좌에 걸친 대변과 차변은 항상 맞아 떨어져야 한다.
    - 그러나 ACID의 일관성은 **애플리케이션의 불변식 개념에 의존**한다.
        - 일관성을 유지하도록 **트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임**이다.
        - 데이터베이스는 불변식을 위반하는 잘못된 데이터가 쓰여지는 것을 막을 수 없다.
    - 즉, **ACID의 일관성은 데이터베이스만으론 달성할 수 없고**, 따라서 일관성은 **ACID에 속하지 않는다**.
- **격리성(Isolation)**
    - 격리성은 여러 클라이언트들이 동일한 DB 레코드에 접근할 때 발생하는 **동시성 문제(경쟁 조건)** 을 다룬다.
    - 격리성은 **동시에 실행되는 트랜잭션이 서로 격리**되는 것을 의미하며, 따라서 **트랜잭션은 서로 다른 트랜잭션을 방해할 수 없다**.
    - 고전적으로 격리성을 **직렬성**이라는 용어로 공식화환다.
        - 직렬성은 각 트랜잭션이 전체 DB에서 실행되는 유일한 트랜잭션인 것처럼 동작하도록 할 수 있다는 것을 의미한다.
        - 실제로 여러 트랜잭션이 동시에 실행됐더라도 *트랜잭션이 커밋됐을 때* 의 결과가 *트랜잭션이 순차적으로 실행됐을 때* 의 결과와 동일하도록 보장한다.
    - 그러나 **직렬성 격리(serializable isolation)** 는 성능 손해를 동반하므로 현실에선 거의 사용되지 않는다.
        - 대중적인 DB 중에는 직렬성 격리를 아예 구현하지 않는 것도 있다.
        - 오라클의 “직렬성” 격리 수준의 경우, 실제로는 직렬성보다 보장이 약한 **스냅숏 격리**를 구현한 것이다.
- **지속성(Durability)**
    - 데이터베이스 시스템의 목적은 **데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공**하는 것이다.
    - 지속성은 **트랜잭션이 성공적으로 커밋됐다면** 하드웨어 결함, DB 다운이 발생해도 **트랜잭션에서 기록한 모든 데이터는 손실되지 않는다**는 보장이다.
    - 단일 노드 DB에서의 지속성
        - 데이터가 하드디스크나 SSD와 같은 비휘발성 저장소에 기록됐다는 것을 의미
        - 디스크의 데이터 구조가 오염됐을 때 복구할 수 있는 WAL 또는 비슷한 수단을 동반한다.
    - 복제 기능이 있는 DB에서의 지속성
        - 성공적으로 다른 몇 개의 노드에 복사가 됐다는 것을 의미
        - 지속성을 보장하려면 DB는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.
    - 완벽한 지속성은 존재하지 않는다.
        - 모든 하드디스크와 백업이 동시에 파괴되면 손 쓸 방도가 없다.

### 단일 객체 연산과 다중 객체 연산

- ACID의 원자성과 격리성은 한 트랜잭션 내에서 여러 번의 쓰기를 하면 DB가 어떻게 해야 하는지를 서술한다.
    - **원자성**
        - 쓰기를 이어 실행하던 도중 오류가 생기면 트랜잭션은 abort돼야 하고, 쓰여진 내용은 폐기돼야 한다.
        - 전부 반영 or 미반영 중 택1을 보장하므로 **부분 실패를 걱정할 필요가 없어진다**.
    - **격리성**
        - 동시에 실행되는 트랜잭션은 서로를 방해하지 않아야 한다.
        - 한 트랜잭션의 여러 쓰기를 다른 트랜잭션은 전부 보거나 전부 볼 수 없어야 한다. 즉, 다른 트랜잭션이 **일부분만 볼 수 있어선 안 된다**.
- **다중 객체 트랜잭션**
    - 여러 데이터 조각이 동기화된 상태로 유지돼야할 때 다중 객체 트랜잭션이 필요한다.
        - 예를 들어, “email 테이블”에 새로운 이메일 레코드가 추가되면 즉시 다른 테이블의 “읽지 않은 메시지 수” 칼럼 값을 갱신해줘야 하는 경우
    - 격리성 위반 예시
        - 위 예시처럼 이메일 추가 시 읽지 않은 메시지 건수를 mailboxes에 업데이트한다.
        - 사용자2가 다른 트랜잭션의 커밋되지 않은 데이터를 읽게 되면(**더티 읽기, dirty read**) 읽기 않은 메시지가 있음에도 읽지 않은 메시지 개수가 0으로 반환되는 이상현상을 겪게 됨
    
    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/099f0ad5-291a-463c-a85f-e91873cf6306)
    
    - 원자성 위반 예시
        - 위 예시에서 사용자 1이 insert를 수행하고 mailboxes에 대한 update를 수행하기 직전 오류가 발생할 경우, 메일함의 내용과 읽지 않은 메시지 개수가 동기화되지 않을 수 있다.
        - 원자적 트랜잭션에선 위와 같은 실패가 발생하면 트랜잭션이 abort되고 삽입된 이메일은 롤백한다.
    - 다중 객체 트랜잭션은 읽기, 쓰기 연산이 동일한 트랜잭션에 속하는지 알 수단이 필요하다.
        - 관계형 DB
            - 클라이언트-DB 사이의 TCP 연결을 기반으로 알 수 있다.
            - 특정 연결 내에서 `BEGIN TRANSACTION` 문과 `COMMIT` 문 사이의 모든 것을 같은 트랜잭션에 속한다고 여긴다.
        - 비관계형 DB
            - 관계형처럼 연산을 묶는 방법이 없는 경우가 많다.
            - 어떤 키에 대한 연산은 성공하고 나머지는 실패해서 DB가 부분적으로 갱신된 상태가 될 수 있다.
- **단일 객체 쓰기**
    - 단일 객체를 변경하는 경우 원자성과 격리성 고려 문제
        - 데이터 전송 중 네트워크 단절로 일부만 받는다면 DB는 이를 저장할 것인지?
        - DB가 디스크의 기존 값을 덮어쓰다가 전원이 나가면 기존 값과 새 값이 붙어있게 될까?
        - 문서 작성 중에 다른 클라이언트가 읽으면 부분적으로 갱신된 값을 읽게 될까?
    - 저장소 엔진들은 보편적으로 위 문제들을 피하기 위해 **한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공**하는 것을 목표로 한다.
        - 원자성은 장애 복구(crash recoverty)용 로그를 써서 구현
        - 격리성은 각 객체에 잠금(동시에 한 스레드만 객체에 접근)을 사용해 구현
    - 이러한 단일 객체 연산은 여러 클라이언트가 동시에 같은 객체에 쓰려고 할 때 **갱신 손실(lost update)** 을 방지하므로 유용하다.
    - 트랜잭션은 보통 **다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘**으로 이해된다.
- **다중 객체 트랜잭션의 필요성**
    - 많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다.
        - 여러 파티션에 걸쳐 구현하기 어렵고
        - 매우 높은 가용성과 성능이 필요한 곳에선 방해가 되므로
        - 하지만 분산 DB에서 근본적으로 트랜잭션을 막는 요소는 없다.
    - 단일 객체 삽입, 갱신, 삭제 만으로 충분한 사례도 있다.
    - 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션돼야 한다.
        - 관계형 데이터 모델의 로우는 다른 테이블 로우를 참조하는 **외래 키**를 가진다. → 서로 참조하는 레코드들을 삽입할 때, **참조 키는 올바르고 최신 상태를 반영해야** 한다.
        - 문서 데이터 모델에선 **함께 갱신돼야 하는 필드들이 단일 객체로 비정규화**되어 다뤄진다. → 비정규화된 정보를 갱신할 때 한 번에 여러 문서를 갱신해야 하며 **트랜잭션은 이런 상황에서 동기화가 깨지는 것을 방지**한다.
        - 보조 색인이 있는 DB에선 값을 변경할 때마다 색인도 갱신돼야 한다. → 격리성이 없으면 색인마다 보이는 레코드가 달라지는 문제가 생길 수 있다.
    - 트랜잭션이 없더라도 이러한 애플리케이션을 구현할 순 있지만 원자성, 격리성 부재로 인한 문제를 겪을 수 있다.
        - **원자성**이 없으면 **오류 처리**가 훨씬 더 복잡해진다.
        - **격리성**이 없으면 **동시성 문제**가 생길 수 있다.
- **오류와 어보트 처리**
    - 트랜잭션의 핵심 기능은 오류가 생기면 abort되고 안전하게 재시도할 수 있다는 점이다.
    - 하지만 모든 시스템이 이 철학을 따르진 않는다.
        - “**리더 없는 복제**”를 사용하는 데이터스토어는 **best effort 원칙**을 기반으로 한다.
        - DB는 가능한 모든 일을 수행하며 **오류가 발생하면 이미 한 일은 취소하지 않는다**.
        - 따라서 **오류 복구에 대한 책임은 애플리케이션에게 있다**.
    - 어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만, 완벽하지는 않다.
        - 트랜잭션이 실제로 성공했지만 커밋 성공을 알리는 도중 네트워크가 끊겼을 때 재시도하면 트랜잭션이 두 번 실행된다. → 애플리케이션에 추가적인 중복 제거 메커니즘 필요
        - 과부하로 인해 발생한 오류라면 재시도가 문제를 악화시킬 수 있다. → 재시도 횟수 제한 등 필요
        - 일시적인 오류만 재시도할 가치가 있으며 영구적인 오류는 재시도해도 아무 소용이 없다.
            - 일시적 오류 : 교착 상태, 격리성 위반, 네트워크 단절, 장애 복구 등
            - 영구적인 오류 : 제약 조건 위반위반
        - 트랜잭션이 DB 외부에 부수적인 효과를 주는 경우 재시도는 원치 않는 부수효과를 가져올 수 있다. (이메일 재전송 등) → 2단계 커밋 등 필요

## 완화된 격리 수준

- **동시성 문제(경쟁 조건)** 가 나타나는 건 다음 두 가지 경우 뿐이다.
    - 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나
    - 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때
- 따라서 두 트랜잭션이 **동일한 데이터에 접근하지 않으면** 서로 의존하지 않으므로 **안전하게 병렬 실행될 수 있다**.
- 동시성 버그는 타이밍 문제로 발생하므로 테스트로 발견하기 어렵고 재현도 어렵고 추론하기도 어렵다.
- 이런 이유로 데이터베이스는 오랫동안 **트랜잭션 격리**를 제공함으로써 개발자들에게 동시성 문제를 감춰왔다.
    - 이론상 격리성은 동시성이 없는 것처럼 행동할 수 있다.
    - 직렬성 격리는 DB가 여러 트랜잭션들이 직렬적으로 실행되는 것과 동일한 결과를 보장한다.
- 그러나 격리는 간단하지 않고 성능 비용도 지불해야한다.
- 따라서 현장에선 **완화된 격리 수준을 사용하는 시스템들이 흔하다**.
    - 완화된 격리는 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는다.
- 완화된 트랜잭션 격리의 문제
    - 이런 격리성은 이해하기 훨씬 어렵고 미묘한 버그를 유발할 수 있다.
    - 실제로 상업적 금전적 손실을 일으켰고 때문에 금융 데이터의 경우엔 ACID DB를 사용하게 되었다.
    - 하지만 널리 사용되는 관계형 DB조차도 완화된 격리성을 사용하는 경우가 많아서 이런 버그를 반드시 막지는 못 한다.
- 이번 절에선 현장에서 사용되는 완화된(비직렬성) 격리 수준을 살펴보고, 발생할 수 있는 경쟁 조건과 발생할 수 없는 경쟁 조건, 그리고 직렬성을 살펴본다.

### 커밋 후 읽기

- **커밋 후 읽기(read committed)** 는 가장 기본적인 수준의 트랜잭션 격리로 두 가지를 보장한다.
    - DB에서 읽을 때 커밋된 데이터만 읽게 된다. → **더티 읽기**가 없음
    - DB에 쓸 떄 커밋된 데이터만 덮어쓰게 된다. → **더티 쓰기**가 없음
- **더티 읽기 방지**
    - **더티 읽기** : 트랜잭션이 DB에 데이터를 썼지만 아직 커밋 or 어보트되지 않았을 때 다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있는 것
    - 커밋 후 읽기 격리 수준에서 실행되는 트랜잭션은 더티 읽기를 막아야 한다.
    - 더티 읽기를 막는게 유용한 이유
        - 트랜잭션이 여러 객체를 갱신할 때 더티 읽기가 생기면 다른 트랜잭션에서 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다.
        - 트랜잭션이 어보트되면 쓴 내용을 롤백해야 하는데, 더티 읽기가 허용되면 나중에 롤백될 데이터(커밋되지 않을 데이터)를 볼 수 있게 된다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/947f4b94-d9df-453d-9a47-5bc1fca9d134)

- **더티 쓰기 방지**
    - **더티 쓰기** : 먼저 쓰여진 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고, 나중에 실행된 쓰기 작업이 커밋되지 않은 이 값을 덮어써버리는 것
    - 커밋 후 읽기 격리 수준에서 실행되는 트랜잭션은 더티 쓰기를 막아야 한다.
    - 보통 먼저 쓴 트랜잭션이 커밋 or 어보트될 때까지 **두 번째 쓰기를 지연시키는 방법**을 사용한다.
    - 더티 쓰기를 막음으로써 몇 가지 **동시성 문제를 회피**할 수 있다.
        - 트랜잭션들이 여러 객체를 갱신하면 더티 쓰기는 나쁜 결과를 초래한다. 아래 중고차 구매 예시에서 자동차 구매는 두 번의 DB 쓰기가 필요하다. (“목록”, “송장” 테이블) 더티 쓰기가 있을 경우, 판매자와 송장수신자가 각각 최종 갱신한 서로 다른 사람으로 지정되는 문제가 생긴다.
        - 그러나 커밋 후 읽기는 **여러 사용자가 동시에 카운터를 증가시키는 것과 같은 경쟁 조건은 막지 못한다. (더티 쓰기가 아니므로)** → 갱신 손실 방지에서 살펴본다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/6e3fad5c-f806-4781-9f73-e1e00753e918)

- **커밋 후 읽기 구현**
    - 커밋 후 읽기는 매우 널리 쓰이는 격리 수준이다. (Oracle 11g, PostgreSQL 등에서 기본 설정)
    - 더티 쓰기 방지 구현
        - 가장 흔한 방법으로 **로우 수준 잠금**을 사용한다.
        - 트랜잭션이 객체(로우, 문서)를 변경하려면 객체에 대한 잠금을 획득해야 한다.
        - 트랜잭션이 커밋 or 어보트될 때까지 잠금을 보유한다.
        - 오직 한 트랜잭션만이 어떤 주어진 객체에 대해 잠금을 보유할 수 있다.
    - 더티 읽기 방지 구현
        - 잠금 대기
            - 마찬가지로 읽기에도 잠금을 사용하는 방법
            - 오랫동안 실행되는 쓰기 때문에 응답시간 지연이 생겨 운용성이 나쁘며 지연으로 인한 연쇄 효과도 발생할 수 있다.
            - 때문에 현실에서 사용하지 않는 방법임
        - 모두 기억
            - **DB가 객체에 대해서** “과거에 커밋된 값”과 “현재 잠금을 가진 트랜잭션에서 쓴 새로운 값”을 **모두 기억**하는 방법
            - 잠금을 가진 트랜잭션이 실행 중인 동안 다른 트랜잭션은 과거의 값을 읽게 된다.

### 스냅숏 격리와 반복 읽기

- 커밋 후 읽기 격리 수준을 사용하더라도 동시성 버그가 생길 수 있는 경우가 남아있다.
- **읽기 스큐(read skew), 비반복 읽기(nonrepeatable read)**
    - 동시성 버그로 인해 발생하는 **시간적인 이상 현상(timing anomaly)** 으로 일관성이 깨진 상태

    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/3d18bc14-e22b-4130-9db9-6d53ca0925ec)
    
    - 위 예시에서 앨리스는 본인 소유의 두 계좌 사이에서 100만원을 송금했으나 타이밍 이슈로 일시적으로 전체 계좌에서 100만원이 사라진 것처럼 인식할 수 있다.
    - 보통 타이밍으로 인한 일시적인 문제를 유발한다.
    - 이런 일시적인 비일관성을 감내할 수 없는 경우가 존재한다.
        - **백업** : 백업 프로세스 도중에도 쓰기는 실행되므로 백업의 일부는 데이터의 과거 버전을, 나머지는 새 버전을 가질 수도 있다. 이런 백업을 사용해 복원하면 **비일관성이 영속적이게 된다**.
        - **분석 질의와 무결성 확인** : 분석 작업의 질의나 주기적인 무결성 확인 작업에서 이와 같은 DB의 비일관성으로 인해 불합리한 결과를 반환할 수 있다.
- **스냅숏 격리**
    - 읽기 스큐와 같은 문제를 해결하기 위한 흔한 방법이다.
        - PostgreSQL, MySQL, Oracle, SQL Server 등
    - 각 트랜잭션은 DB의 **일관된 스냅샷으로부터 읽는다**.
    - 즉, 트랜잭션은 시작할 때 DB에 **커밋된 상태였던 모든 데이터**를 읽게 된다.
    - 다른 트랜잭션에 의해 데이터가 이후에 변경되더라도 **각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐**이므로 영향이 없다.
    - 스냅숏 격리는 백업, 분석처럼 실행에 오랜 시간이 걸리며 읽기만 실행하는 질의에 유용하다.
- **스냅숏 격리 구현**
    - 커밋 후 읽기 격리처럼 더티 쓰기를 방지하기 위해 **쓰기 잠금**을 사용한다.
    - 그러나 **읽을 때는 아무 잠금도 필요 없다**.
        - 읽는 쪽에선 쓰는 쪽을 차단하지 않고, 쓰는 쪽에서 읽는 쪽을 차단하지 않는다.
        - 따라서 DB는 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리된다.
        - 또한, 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있다.
    - 스냅숏 격리를 구현하기 위해 **다중 버전 동시성 제어(MVCC)** 를 사용한다.
        - DB는 각 객체마다 커밋된 버전 여러 개를 유지한다.
        - 진행 중인 여러 트랜잭션에서 서로 다른 시점의 DB 상태를 봐야할 수도 있기 때문
    - MVCC와 커밋 후 읽기의 모두 기억 방식
        - 앞서 커밋 후 읽기의 모두 기억 방식은 **객체마다 버전 두 개씩만 유지**하면 충분했다. (커밋 전 버전과 덮어 쓰여졌지만 아직 커밋되지 않은 버전)
        - 그러나 **실제론** 스냅숏 격리를 지원하는 저장소 엔진에선 **커밋 후 읽기에도 MVCC를 사용**한다.
            - 커밋 후 읽기 : 질의마다 독립된 스냅숏을 사용
            - 스냅숏 격리 : 전체 트랜잭션에 대해 동일한 스냅숏을 사용
    - MVCC 기반으로 스냅숏 격리를 구현하는 방법
        - 트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID인 `txid` 를 할당받으며 트랜잭션이 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 `txid` 가 함께 입력된다.
        - 각 로우에는 그 로우를 삽입한 트랜잭션의 ID를 값으로 갖는 `created_by` 필드가 존재한다.
        - 각 로우에는 처음엔 빈 값 상태인 `deleted_by` 필드가 존재한다.
        - 트랜잭션이 로우를 삭제하면 실제로 지워지지 않고 `deleted_by` 필드에 삭제를 요청한 트랜잭션의 `txid` 를 입력함으로써 지워졌다고 표시한다.
        - 실제 삭제는 나중에 해당 데이터에 대한 접근이 없는게 확실해지면 가비지 컬렉션 프로세스가 지워졌다고 표기된 로우들을 삭제하여 사용량을 줄인다.
        - 갱신은 내부적으로 삭제와 생성으로 변환된다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/6272acaa-481f-4344-9e5f-16049908b51b)

- **일관된 스냅숏을 보는 가시성 규칙**
    - 트랜잭션이 DB에서 객체를 읽을 때 트랜잭션ID를 사용해 볼 수 있는 데이터의 **가시성 규칙**은 다음과 같다.
        1. DB는 각 트랜잭션이 시작할 시점에 진행 중인 모든 트랜잭션의 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 모두 무시된다.
        2. 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
        3. 트랜잭션ID가 더 큰 트랜잭션이 쓴 데이터는 커밋 여부와 관계없이 모두 무시된다.
        4. 이 이외의 모든 데이터는 애플리케이션 질의로 볼 수 있다.
    - 예시
        - 그림 7-7에서 트랜잭션12가 계좌2를 읽으면 잔고가 500달러 있는 것으로 보인다.
        - 규칙 3에 따라 트랜잭션12는 트랜잭션13의 500달러 잔고 삭제를 볼 수 없고 400달러 잔고 생성 역시 볼 수 없다.
    - 달리 말하면 아래 두 조건이 모두 참이면 객체를 볼 수 있다.
        - “읽기를 실행하는 트랜잭션”이 시작한 시점에, “읽기 대상 객체를 생성한 트랜잭션”이 **이미 커밋된 상태**였다.
        - 읽기 대상 객체가 **삭제된 것으로 표시되지 않았다**. 또는 삭제 표시됐더라도 읽기를 실행한 트랜잭션이 시작한 시점에 **삭제 요청 트랜잭션이 커밋되지 않았다**.
    - 오래 실행되는 트랜잭션은 오랫동안 스냅숏을 사용해서 (다른 트랜잭션 관점에서) 덮어쓰여지거나 삭제된지 오래된 값을 계속 읽고 있을 수도 있다.
    - DB는 갱신할 때 값을 교체하지 않고 새 버전을 생성함으로써 일관된 스냅숏을 제공할 수 있다. (약간의 오버헤드)
- **색인과 스냅숏 격리**
    - 다중 버전 데이터베이스에서 색인이 동작하는 방법은 두 가지가 있다.
    1. 단순하게 색인이 객체의 모든 버전을 가리키게 하는 방법
        - 색인이 모든 버전을 가리키고 현재 트랜잭션에서 볼 수 없는 버전을 걸러내는 방식이다.
        - 가비지 컬렉션이 오래된 객체 버전을 삭제할 때 대응되는 색인 항목도 삭제된다.
    2. append-only/copy-on-write B 트리의 스냅숏
        - 카우치DB, 데이토믹, LMDB에선 **B 트리**를 사용하지만 **추가 전용(append-only) 이며 쓸 때 복사되는(copy-on-write) 변종**을 사용한다.
        - 트리의 페이지가 갱신될 때 덮어쓰는 대신 새로운 복사본을 생성한다.
        - 트리의 루트에 이르기까지 존재하는 부모 페이지들은 복사되고 자식들은 새 버전을 가리키도록 갱신된다.
        - 쓰기를 실행하는 트랜잭션은 **새로운 B 트리 루트를 생성**하게 되며 그것이 생성된 시점에 해당하는 **DB의 일관된 스냅숏**이 된다.
        - 쓰기 마다 새로운 트리 루트를 생성하며 기존의 B 트리를 변경할 수 없으므로 트랜잭션ID를 기반으로 객체를 걸러낼 필요가 없다.
        - 단, 이 방법도 컴팩션과 카비지 컬렉션을 실행하는 백그라운드 프로세스가 필요하다.
- **반복 읽기와 혼란스러운 이름**
    - 스냅숏 격리는 이를 구현한 많은 DB에서 다른 이름으로 불린다.
    - Oracle에선 **직렬성**, PostgreSQL과 MySQL에선 **반복 읽기(repeatable read)** 라 불린다.
    - SQL 표준에 스냅숏 격리의 개념이 없기 때문이다.
    - SQL 표준이 만들어지던 당시 스냅숏 격리가 발명되기 전이었고, 대신 표면적으로 비슷해보이는 반복 읽기가 SQL 표준에 정의되었다.
    - SQL 표준의 격리 수준 정의에는 결함이 있다. 모호하고 부정확하며 구현 독립적이지 않다.

### 갱신 손실 방지

- 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌로 **갱신 손실(lost update)** 문제가 있다.
- 갱신 손실 문제는 DB에서 **값을 읽고 변경한 후 변경된 값을 다시 쓸 때 (read-modify-write 주기)** 발생할 수 있다.
- 두 트랜잭션이 read-modify-write 작업을 동시에 하면 **두 번째 쓰기는 첫 번째 변경을 포함하지 않으므로** 변경 중 하나는 **손실**될 수 있다. (나중에 쓴 것이 먼저 쓴 것을 **때려눕힌다, clobber**라고 표현한다.)
- 이러한 패턴은 다양한 시나리오에서 발생한다.
    - 카운터를 증가시키거나 계좌 잔고를 갱신하는 경우
    - 복잡한 값을 지역적으로 변경하는 경우 (e.g. JSON 문서 내 리스트에 엘리먼트를 추가하기 위해 문서를 파싱-변경-쓰기를 수행하는 경우)
    - 위키 페이지를 두 명의 사용자가 동시에 편집하는 경우
- 갱신 손실은 이렇게 흔한 문제여서 다양한 해결책이 개발됐다.
- **원자적 쓰기 연산**
    - 보통 가장 좋은 해결책은 DB에서 제공하는 **원자적 갱신 연산**을 사용하는 것이다.
    - 핵심은 **애플리케이션 코드에서 read-modify-write 주기를 구현하지 않도록 하는 것**이다.
    - 예를 들어 다음 명령은 대부분 관계형 DB에서 **동시성 안전(concurrency-safe)** 하다.
    
    ```sql
    UPDATE counters SET cnt = cnt + 1 WHERE key = 'foo';
    ```
    
    - 관계형 외 원자적 연산 제공 사례
        - MongoDB 등 문서 데이터베이스는 JSON 문서의 일부를 지역적으로 변경하는 원자적 연산을 제공한다.
        - 레디스는 priority queue 같은 데이터 구조를 변경하는 원자적 연산을 제공한다.
    - 원자적 연산은 보통 객체를 읽을 때 **독점적인(exclusive) 잠금**을 획득해서 구현한다.
        - 이 기법을 **커서 안정성(cursor stability)** 라 부른다.
        - 다른 선택지는 그냥 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 것이다.
    - **ORM 객체 관계형 매핑 프레임워크를 사용하면 DB에서 제공하는 원자적 연산을 사용하는 대신 불안전한 read-modify-write 주기를 실행하는 코드를 작성하기 쉽다**.
- **명시적인 잠금**
    - DB에 내장된 원자적 연산이 필요한 기능을 제공하지 않는다면 애플리케이션 코드에서 갱신할 객체를 명시적으로 잠그는 방법을 쓸 수도 있다.
    - 이렇게 하면 애플리케이션이 read-modify-write 주기를 수행할 수 있고
    - 다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면 첫 번째 read-modify-write 주기가 완료될 때까지 기다리도록 강제한다.
    
    ```sql
    BEGIN TRANSACTION;
    
    SELECT * 
    FROM figures
    WHERE name = 'robot' AND game_id = 222
    FOR UPDATE;  -- 이 질의에 의해 반환된 모든 로우에 잠금을 획득해야 함을 의미
    
    -- 유효성 확인 후 이전의 SELECT에서 반환된 것의 위치를 갱신한다.
    UPDATE figures SET position = 'c4' WHERE id = 1234;
    
    COMMIT;
    ```
    
    - 올바르게 동작하려면 로직에 대해 신중해야 한다. 코드 어딘가에 **필요한 잠금을 추가하는 것을 잊어버려서 경쟁 조건을 유발하기 쉽다**.
- **갱신 손실 자동 감지**
    - 원자적 연산과 잠금은 read-modify-write 주기가 **순차적**으로 실행되도록 강제함으로써 **갱신 손실을 방지**하는 방법이다.
    - 대안으로 **갱신 손실 자동 감지**는 이들의 **병렬 실행을 허용**하고 트랜잭션 관리자가 **갱신 손실을 발견하면 트랜잭션을 어보트**시키고 read-modify-write **주기를 재시도하도록 강제**하는 방법이다.
    - 사례
        - PostgreSQL의 반복 읽기, Oracle의 직렬성, SQL Server의 스냅숏 격리 수준은 갱신 손실이 발생하면 자동으로 발견하여 문제가 되는 트랜잭션을 어보트시킨다.
        - 반면 MySQL, 이노DB의 반복 읽기는 갱신 손실을 감지하지 않는다.
    - 장점
        - DB가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다
        - 애플리케이션 코드에서 어떤 특별한 DB 기능을 쓸 필요가 없게 도와주므로 매우 유용하다.
        - 잠금이나 원자적 연산을 쓰는 것을 잊어버려서 버그를 유발할 수는 있지만 자동으로 갱신 손실이 감지된다면 오류가 덜 발생하게 된다.
- **Compare-and-set**
    - 트랜잭션을 제공하지 않는 DB 중에는 원자적 compare-and-set 연산을 제공하는 것도 있다.
    - 값을 마지막으로 읽은 후로 **변경되지 않았을 때만 갱신을 허용**함으로써 **갱신 손실을 회피**한다.
    - 현재 값이 이전에 읽은 값과 다르면 갱신은 반영되지 않고, read-modify-write 주기를 재시도해야 한다.
    
    ```sql
    -- DB 구현에 따라 안전하지 않을 수 있으므로 주의
    UPDATE wiki_pages SET content = 'new content'
    WHERE id = 1234 AND content = 'old content';
    ```
    
    - 그러나 DB가 WHERE 절이 오래된 스냅숏으로부터 읽는 것을 허용한다면 위 구문은 갱신 손실을 막지 못할 수도 있다. (동시에 다른 쓰기 작업이 실행되고 있더라도 조건이 참이 될 수 있으므로)
    - compare-and-set 연산을 쓰기 전에 반드시 안전한지 확인해야 한다.
- **충돌 해소와 복제**
    - **복제가 적용된 DB**는 여러 노드에 복사본이 있고 데이터가 다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하려면 추가 단계가 필요하다.
    - 잠금과 compare-and-set 연산은 데이터의 최신 복사본이 하나뿐인 경우를 가정했다.
    - 하지만 다중 리더, 리더 없는 복제 DB에선 여러 쓰기가 동시에 실행되고 비동기식 복제를 허용하므로 **데이터의 최신 복사본이 하나만 있으리라고 보장할 수 없다**.
    - 복제가 적용된 DB에서 흔히 쓰는 방법은, 한 값에 대해 여러 개의 **충돌된 버전(형제, sibling) 을 생성하는 것을 허용**하고, **사후에 충돌을 해소하여 이 버전들을 병합**하는 것이다. (애플리케이션 코드나 특별한 데이터 구조를 사용해서)
    - 반면, **최종 쓰기 승리(last write wins, LWW)** 충돌 해소 방법은 **갱신 손실이 발생하기 쉽다**.
    - 유감스럽게도 **많은 복제 데이터베이스는 LWW가 기본** 설정이다.

### 쓰기 스큐와 팬텀

- 데이터 오염을 피하기 위해 두 경쟁조건(더티 쓰기, 갱신 손실)에 대해 알아봤으나, 동시 쓰기 작업 사이에 잠재적으로 발생할 수 있는 경쟁 조건은 더 있다.
- 의사들의 호출 대기를 관리하는 애플리케이션의 예시
    - 요구사항 : 반드시 최소 한 명의 의사는 호출 대기를 유지해야 한다
    - 스냅숏 격리를 사용하며, 두 사용자가 동시에 최소 호출 대기 인원을 확인한 후 동시에 호출 대기를 종료한다. 이 경우 요구사항을 만족하지 않게 된다.
    
    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/ffdf24ea-803c-4071-bf9d-96fcb82eff9f)
    
- **쓰기 스큐를 특징짓기**
    - **쓰기 스큐(write skew)** : 두 트랜잭션이 같은 객체를 읽고 그 중 일부를 갱신할 때 나타날 수 있다.
    - 두 트랜잭션이 같은 객체가 아니라 서로 다른 객체를 갱신하므로 **더티 쓰기도 갱신 손실도 아니다**.
    - 그러나 두 트랜잭션이 동시에 실행되며 충돌하므로 **경쟁 조건**이다.
    - 쓰기 스큐가 갱신 손실을 막기 어려운 이유
        - **여러 객체가 관련**되어 원자적 단일 객체연산이 도움 안 됨
        - 스냅숏 격리 구현에서 제공되는 갱신 손실 자동 감지도 도움 안 됨
        - 쓰기 스큐를 자동으로 방지하려면 진짜 직렬성 격리가 필요함
        - 예시(최소 한 명이 호출 대기할 것)처럼 쓰기 스큐를 유발하는 제약 조건은 대부분의 DB에서 지원하지 않는 제약 조건임
        - 직렬성 격리 수준을 사용할 수 없다면 트랜잭션이 의존하는 로우를 명시적으로 lock하는 것이 차선책 (select for update)
        
        ```sql
        BEGIN TRANSACTION;
        
        SELECT * FROM doctors
        WHERE on_call = true
        AND shift_id = 1234 FOR UPDATE;
        
        UPDATE doctors
        SET on_call = fals
        WHERE name = 'Alice'
        AND shift_id = 1234;
        
        COMMIT;
        ```
        
- **추가적인 쓰기 스큐의 예**
    - 회의실 예약 시스템
        - 예약 테이블을 검색하여 확인한 후, insert하는 방식으로 예약 내역을 추가하는 경우
        - 스냅숏 격리는 다른 사용자가 동시에 같은 회의 예약을 삽입하는 것을 막지 못 한다.
        - 스케줄 충돌 방지를 보장하려면 직렬성 격리가 필요하다.
        
        ```sql
        BEGIN TRANSACTION;
        
        SELECT COUNT(*) FROM bookings
        WHERE room_id = 123 
        AND end_time > '2015-01-01 12:00' AND start_time < '2015-01-01 13:00';
        
        INSERT INTO bookings
        (room_id, start_time, end_time, user_id)
        VALUES (123, '2015-01-01 12:00', '2015-01-01 13:00', 666);
        
        COMMIT;
        ```
        
    - 다중플레이어 게임
        - 갱신 손실을 막기 위한 잠금은 플레이어들이 서로 다른 물체를 옮기는 것을 막지 못 한다.
    - 사용자명 획득
        - 웹 사이트에서 두 명의 사용자가 동시에 같은 이름으로 계정을 생성을 시도하는 경우 (각자 동시에 계정명 확인 후 계정 생성)
        - 스냅숏 격리는 동일한 계정명이 생기는 것을 막지 못 한다.
        - 단, 이 경우는 유일성 제약 조건으로 간단히 해결 가능하다.
    - 이중 사용(double-spending) 방지
        - 사용자가 돈이나 포인트를 지불할 때 갖고 있는 것보다 더 많이 지불하지 않는지 확인해야 한다.
        - 지불 예정 항목을 사용자 계좌에 삽입하는 방식이라면 마찬가지로 쓰기 스큐가 발생할 수 있다.
- **쓰기 스큐를 유발하는 팬텀**
    - 쓰기 스큐가 발생하는 패턴
        1. SELECT 질의로 특정 조건에 부합하는 로우를 검색하여 요구사항을 만족하는지 확인한다.
        2. 1번 질의 결과에 따라 코드는 연산을 진행할지, 중단할지를 결정한다.
        3. 진행한다면, DB에 쓰기를 수행하고(insert, update, delete) 커밋한다. 이 쓰기로 2번을 결정한 전제 조건(요구사항)이 변경된다.
    - 경우에 따라 패턴이 다른 순서로 나타날 수 있다. (쓰기 → 검색 → 결정)
    - 쓰기 스큐를 회피하기 위해 1단계의 로우를 잠글 수 있다.(select for update)
    - 그러나 1단계의 질의가 아무 로우도 반환하지 않는다면 select for update는 아무것도 잠글 수 없다.
    - 이처럼 어떤 트랜잭션의 쓰기가 다른 트랜잭션의 검색 결과를 바꾸는 효과를 **팬텀(phantom)** 이라 한다.
    - **스냅숏 격리는 읽기 전용 질의에서는 팬텀을 회피**하지만 위와 같은 패턴에선 **팬텀이 쓰기 스큐를 유발**할 수 있다.
- **충돌 구체화**
    - DB에 **인위적으로 잠금 객체를 추가**하여 팬텀 문제를 해결할 수도 있다.
    - **충돌 구체화(materializing conflict)** : 팬텀을 DB에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환하는 방법
    - 충돌을 구체화하는 방법은 알아내기 어렵고 오류도 발생하기 쉽다.
    - 다른 대안이 불가능할 때 최후의 수단으로 고려해야 한다.
    - 회의실 예약 예시의 경우, 회의실과 시간 범위의 모든 조합에 대해 로우를 미리 만들어 로우를 잠글 수 있다.(select for update)

## 직렬성

- 직렬성 격리가 필요한 몇 가지 이유
    - 격리 수준은 이해하기 어렵고 DB마다 구현에 일관성이 없다.
    - 애플리케이션 코드가 특정 격리 수준에서 실행되는게 안전한지 알기 어렵다.
    - 경쟁 조건을 감지하는데 도움이 되는 도구가 딱히 없다.
- 직렬성 격리는 보통 **가장 강력한 격리 수준**으로 여겨진다.
- 여러 트랜잭션이 병렬로 실행되더라도 **최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장**한다.
- 즉, 발생할 수 있는 **모든 경쟁 조건을 데이터베이스가 막아준다**.
- 직렬성 제공을 위해 DB가 사용하는 세 가지 기법
    1. *트랜잭션을 순차적으로 실행하기*
    2. *2단계 잠금*
    3. *직렬성 스냅숏 격리 같은 낙관적 동시성 제어*

### 실제적인 직렬 실행

- 단일 스레드 루프에서 실질적인 트랜잭션 실행이 실현 가능해진 것은 상당히 최근(2007년경)이다. 이유는 크게 두 가지다.
    - 램 가격 하락으로 트랜잭션이 접근할 데이터셋 전체를 메모리에 유지할 수 있게 됨
    - OLTP 트랜잭션은 보통 짧고 읽기 쓰기 수가 적으며 반대로 분석 질의는 전형적인 읽기 전용이라 일관된 스냅숏을 사용해 실행 가능하다.
- 동시성 시스템과 성능 비교
    - **잠금을 코디네이션하는 오버헤드가 없어** 동시성을 지원하는 시스템보다 성능이 나을 때도 있다.
    - 그러나 처리량은 **CPU 코어 하나의 처리량으로 제한**된다.
    - 즉, 단일 스레드를 최대한 활용하려면 **트랜잭션이 전통적인 형태와는 다르게 구조화돼야** 한다.
- **트랜잭션을 스토어드 프로시저 안에 캡슐화하기**
    - 거의 모든 OLTP 애플리케이션은 상호작용식 트랜잭션을 사용하며 트랜잭션을 짧게 유지한다.
        - 웹의 경우 트랜잭션이 동일한 HTTP 요청 내에서 커밋되며 새로운 HTTP 요청은 새로운 트랜잭션을 시작한다.
        - 상호작용식 트랜잭션은 앱과 DB 사이의 네트워크 통신에 많은 시간을 소비한다.
        - 이런 구조에서 순차적 처리는 많은 대기 시간을 소요하므로 적절하지 않고, 쓸만한 성능을 위해 동시에 여러 트랜잭션을 처리한다.
    - 반면, 단일 스레드에서 트랜잭션을 순차적으로 처리하는 시스템은 **상호작용하는 다중 구문 트랜잭션을 허용하지 않는다**.
        - 대신 애플리케이션은 트랜잭션 코드 전체를 **스토어드 프로시저** 형태로 DB에 미리 제출해야 한다.
- **스토어드 프로시저의 장단점**
    - 스토어드 프로시저의 단점
        - DB 벤더마다 스토어드 프로시저용 언어가 제각각이며 매우 조잡하고 낡았고 라이브러리 생태계가 빈약하다.
        - DB에서 실행되는 코드는 관리하기가 어렵다. (디버깅, 버전 관리, 배포, 모니터링 지표 수집 등)
        - 여러 애플리케이션 서버에서 DB 인스턴스 하나를 공유하므로 DB는 애플리케이션보다 훨씬 더 성능에 민감하다. (잘못 작성된 코드가 DB에 주는 악영향이 매우 크다.)
    - 이런 문제를 극복하기 위해 현대의 스토어드 프로시저 구현은 **PL/SQL을 버리고 범용 프로그래밍 언어를 사용**한다.
        - 볼트DB는 java, groovy를 사용
        - 레디스는 Lua를 사용
- **파티셔닝**
    - 트랜잭션의 순차적 처리는 동시성 제어가 간단하지만 **처리량이 단일 CPU 코어의 속도로 제한**된다.
        - 읽기 전용 트랜잭션이라면 스냅숏 격리로 다른 곳에서 실행되어 괜찮지만
        - **쓰기 처리량이 높은 애플리케이션**에선 단일 스레드 트랜잭션 처리가 **심각한 병목**이 될 수 있다.
    - **파티셔닝으로 여러 CPU 코어와 여러 노드로 확장**하여 이를 커버할 수 있다.
        - 각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝한다.
        - 각 파티션은 자신만의 트랜잭션 처리 스레드를 가진다.
        - 트랜잭션 처리량을 CPU 코어 수에 맞춰 선형적으로 확장할 수 있다.
    - **여러 파티션에 접근**하는 트랜잭션의 경우
        - 해당 트랜잭션이 접근하는 **모든 파티션에 걸쳐 코디네이션**을 해야 한다.
        - 스토어드 프로시저는 전체 시스템에 걸쳐 직렬성을 보장하기 위해 모든 파티션에 걸쳐 **잠금**을 획득한 단계에서 실행돼야 한다.
        - 추가적인 코디네이션 오버헤드로 단일 파티션 트랜잭션보다 매우 느리다.
- **직렬 실행 요약**
    - **모든 트랜잭션은 작고 빨라야** 한다. 느린 트랜잭션이 모든 트랜잭션 처리를 지연시키므로
    - 데이터셋이 **메모리**에 적재될 수 있는 경우로 사용이 제한된다.
    - **쓰기 처리량**이 단일 CPU 코어에서 처리할 수 있을 정도로 **충분히 낮아야** 한다.
    - 여러 파티션에 걸친 트랜잭션도 사용 가능하나, 사용에 엄격한 제한이 있다.
    - 직렬 실행은 확장이 잘 되지 않는다.

### 2단계 잠금(2PL)

- **2단계 잠금(two-phase locking; 2PL)** 은 30년간 직렬성을 구현하는데 널리 쓰인 유일한 알고리즘이다.
- 더티 쓰기를 막는데 잠금을 사용하는 것과 비슷하지만 2PL은 더 강력하다.
    - 트랜잭션A가 객체를 읽고, 트랜잭션B가 그 객체에 쓰기를 하려면 커밋, 어보트될 때까지 기다려야 한다.
    - 트랜잭션A가 객체에 썼고, 트랜잭션B가 그 객체를 읽기를 하려면 커밋, 어보트될 때까지 기다려야 한다.
- 스냅숏 격리는 “읽는 쪽은 쓰는 쪽을 막지 않고 그 역도 성립”하는데 반해,
- 2PL은 **쓰기 트랜잭션은 다른 쓰기 트랜잭션 뿐만 아니라 읽기 트랜잭션도 막고** 그 역도 성립한다.
- 2PL은 **직렬성을 제공**하므로 **갱신 손실**과 **쓰기 스큐**를 포함한 **모든 경쟁 조건으로부터 보호**해준다.
- **2단계 잠금 구현**
    - 읽기와 쓰기는 DB의 각 객체에 **잠금**을 사용해 구현하며, 잠금은 **공유 모드(shared mode)** 나 **독점 모드(exclusive mode)** 로 사용된다.
        - 트랜잭션이 *읽기*를 원하면 *공유 모드*로 잠금을 획득한다.
        - 동시에 여러 트랜잭션이 공유 모드로 잠금을 획득할 수 있으나, 독점 모드로 잠금을 획든한 트랜잭션이 있으면 완료까지 기다려야 한다.
        - 트랜잭션이 *쓰기*를 원하면 *독점 모드*로 잠금을 획득한다.
        - 읽다가 쓰기를 실행할 땐 공유 잠금을 독점 잠금으로 업그레이드 해야 한다.
        - 잠금 획득 시 종료(커밋 or 어보트)될 때까지 갖고 있어야 한다.
        - 2단계라는 이름에서 첫 번째 단계는 잠금 획득, 두 번째 단계는 모든 잠금을 해제할 때를 의미한다.
    - 잠금이 많이 사용되므로 트랜잭션이 잠금 해제될 때까지 기다리느라 멈춰있는 상황이 매우 쉽게 발생한다. → **교착 상태**
    - DB는 트랜잭션 사이의 교착 상태를 자동으로 감지하고 트랜잭션 중 하나를 어보트시켜 조율한다. (어보트된 트랜잭션은 애플리케이션에서 재실행해야 한다.)
- **2단계 잠금의 성능**
    - 2PL은 성능이 나빠 1970년대부터 쓰이지 않고 있다.
    - 완화된 격리 수준에 비해 **잠금으로 인하여 트랜잭션 처리량과 질의 응답 시간이 크게 나빠진다**.
    - 주요 원인은 **잠금 획득과 해제의 오버헤드**, **동시성이 줄어드는 것**
    - 전통적인 관계형 DB는 상호작용식 애플리케이션에서 사용자 입력을 기다리도록 설계되므로 트랜잭션이 다른 트랜잭션 종료까지 얼마나 오래 기다려야하는지도 제한이 없다.
    - 잠금 기반 “커밋 후 읽기” 격리 수준에서도 교착 상태가 발생할 수 있지만 2PL 직렬성 격리에선 **훨씬 더 자주 발생**한다.
    - **교착 상태는 부가적인 성능 문제**가 될 수 있으며 교착 상태로 어보트, 재시도하게 되면 **작업을 전부 다시 해야** 한다.
- **서술 잠금**
    - 직렬성 격리는 **팬텀**을 막을 수 있어야 한다.
    - 회의실 예약 예시) 회의실 예약을 검색했다면, 다른 트랜잭션이 동일 범위 및 동일 회의실에 대한 예약을 삽입하거나 갱신하는게 허용되지 않아야 한다.
    - 이를 구현하기 위해 **서술 잠금(predicate lock)** 이 필요하다.
    - 서술 잠금은 **공유 잠금, 독점 잠금과 비슷**하게 동작하지만 특정 객체가 아니라 **어떤 검색 조건에 부합하는 모든 객체에 속한다**.
        - 트랜잭션A가 어떤 조건에 부합하는 객체를 **읽기 원한다면** 질의의 조건에 대한 **공유 모드 서술 잠금**을 획득해야 한다.
        - 다른 트랜잭션B가 그 조건에 부합하는 어떤 객체에 독점 잠금을 갖고 있으면 A는 B가 잠금을 해제하기를 기다려야 한다.
        - 트랜잭션A가 어떤 객체를 **삽입, 갱신, 삭제**하길 원한다면 먼저 **기존 값이나 새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인**해야 한다.
        - 부합하는 서술 잠금을 B가 갖고 있으면 B가 커밋, 어보트될 때까지 기다려야 한다.
    - 핵심은 아직 DB에 없지만 **미래에 추가될 수 있는 객체(팬텀) 에도 서술 잠금을 적용할 수 있다는 것**이다.
    - 2PL이 서술 잠금을 포함하면 DB의 모든 형태의 **쓰기 스큐와 다른 경쟁 조건을 막을 수 있다**. → **격리 수준에서 직렬성 격리가 된다**.
- **색인 범위 잠금**
    - 서술 잠금은 유감스럽게도 잘 동작하지 않는다.
        - 잠금이 많으면 조건에 부합하는 잠금을 확인하는데 시간이 오래 걸림
    - 이 때문에 2PL 지원 DB 대부분은 **색인 범위 잠금(index-range locking)** 이라는 형태로 서술 잠금을 **간략하게 근사하여 구현**한다.
    - 더 많은 객체가 부합하도록 서술 조건을 간략화하는 것은 안전하다.
        - e.g. “12시~13시의 123번 방” 예약에 대한 서술 잠금을 “모든 시간대의 123번 방” 예약으로 잠금을 근사
    - 서술 잠금에서 조건에 사용하는 칼럼들에 걸린 색인을 사용하여 색인 범위 잠금을 건다.
        - (색인이 특정 값일 때) room_id 색인이 있고 123번 방에 예약이 있는지 확인하는데 이 색인을 사용한다. **색인 항목에 공유 잠금을 잡아서 예약을 검색했다고 표시**한다.
        - (색인이 범위일 때) 혹은 시간 기반 색인을 사용한다면 그 **색인의 값들 범위에 공유 잠금**을 잡아서 특정 시간대 예약을 검색했다고 표시할 수 있다.
    - 색인 범위 잠금은 **팬텀**과 **쓰기 스큐**로부터 보호해준다.
    - 색인 범위 잠금은 서술 잠금보다 **정밀하진 않지만 오버헤드가 훨씬 더 낮으므로 좋은 타협안**이 된다.
    - 범위 잠금을 잡을 수 있는 적합한 색인이 없다면 테이블 전체에 공유 잠금을 잡는 것으로 대체할 수 있다. (테이블에 쓰는 모든 트랜잭션을 멈추므로 성능은 안 좋음)

### 직렬성 스냅숏 격리(SSI)

- 앞서 살펴본 동시성 제어를 위한 방법들
    - 한 쪽은 성능이 좋지 않거나(2단계 잠금)
    - 확장이 잘 되지 않거나(직렬 실행)
    - 성능은 좋지만 다양한 경쟁 조건(갱신 손실, 쓰기 스큐, 팬텀)에 취약하거나(완화된 격리 수준)
- **직렬성 스냅숏 격리(serializable snapshot isolation; SSI)** 알고리즘
    - **완전한 직렬성**을 제공하며 스냅숏 격리에 비해 **약간의 성능 손해**만 있을 뿐
    - 오늘날 SSI는 단일 노드 DB와 분산 DB 모두에서 사용한다.
    - 2008년에 처음 기술되어 역사가 짧지만 상당히 유망한 기술이다.
- **비관적 동시성 제어 대 낙관적 동시성 제어**
    - 2단계 잠금은 **비관적 동시성 제어 메커니즘**
        - 뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 다시 안전해질 때까지 기다리는게 낫다는 원칙
        - 다중 스레드 프로그래밍에서 자료구조를 보호하기 위해 사용하는 **상호 배제(mutual exclusion)** 와 비슷하다.
    - 직렬 실행은 극단적으로 비관적
        - 직렬 실행은 트랜잭션이 실행되는 동안 전체 **DB에 독점 잠금**을 획득하는 것과 같다.
        - 개별 트랜잭션을 빨리 실행되게 해서 잠금 유지 시간을 줄이는 것으로 비관주의를 보완한다.
    - 직렬성 스냅숏 격리는 **낙관적 동시성 제어 기법**
        - 위험한 상황 발생 가능성이 있을 때 트랜잭션을 막는 대신 모든 것이 괜찮아질 거라는 희망을 갖고 계속 진행하는 원칙
        - 트랜잭션이 **커밋될 때 DB는 나쁜 상황이 발생했는지(격리가 위반됐는지) 확인**한다.
        - 나쁜 상황이 발생했다면 트랜잭션은 어보트되고 재시도해야 한다.
        - 직렬로 실행된 트랜잭션만 커밋이 허용된다.
    - 낙관적 동시성 제어의 단점과 보완 방법
        - 경쟁이 심해지면 어보트시켜야할 트랜잭션의 비율이 높아져 성능이 떨어진다.
        - 그러나 예비 용량이 충분하고 경쟁이 심하지 않다면 낙관적 제어도 성능이 좋아질 수 있다.
        - 경쟁은 **가환(commutative) 원자적 연산**으로 줄일 수 있다.
            - 예를 들어, 동시에 카운터를 증가시키는 연산은 증가 연산이 어떤 순으로 적용하는지 상관 없으므로 동시에 실행되는 증가연산들을 충돌 없이 적용할 수 있따.
    - SSI는 이름대로 **스냅숏 격리를 기반**으로 한다.
        - 모든 읽기는 DB의 일관된 스냅숏을 보게 된다.
        - 이 점이 **이전의 낙관적 동시성 제어와 크게 다른 점**이다.
        - SSI는 스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가한다.
- **뒤처진 전제에 기반한 결정**
    - 트랜잭션은 어떤 **“전제”** 를 기반으로 어떤 동작을 수행한다. (e.g. 현재 두 명의 의사가 호출 대기 중임)
    - 해당 트랜잭션을 커밋하려고 할 때, 원래 데이터가 바뀌어서 그 “전제” 가 더 이상 참이 아닐 수 있다. → 트랜잭션이 쓰기를 수행한다면 **쓰기 스큐**와 **팬텀**을 유발할 수 있다.
    - 즉, 트랜잭션에서 실행하는 **“질의”** 와 **“쓰기”** 사이에는 **인과적 의존성**이 있을 수 있다.
    - 직렬성 격리를 제공하려면 DB는 **트랜잭션이 뒤처진 전제를 기반으로 동작하는지 감지**하고, 그런 상황에서 트랜잭션을 어보트시켜야 한다.
    - DB는 어떻게 질의 결과가 바뀌었는지 알 수 있을까?
        - *오래된 MVCC 버전을 읽었는지 감지하기* (읽기 전에 커밋되지 않은 쓰기가 시작됨)
        - *과거의 읽기에 영향을 미치는 쓰기 감지하기* (읽은 후에 쓰기가 실행됨)
- **오래된 MVCC 읽기 감지하기**
    - 스냅숏 격리는 보통 다중 버전 동시성 제어(MVCC)로 구현한다.
    - 트랜잭션이 스냅숏에서 읽으면 스냅숏 생성 시점에 **다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터는 무시**한다.
    - 의사의 호출 대기 시 쓰기 스큐 문제 예시
    
    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/d69c009d-cdb0-4af6-b95c-2bdac27d8186)
    
    - 트랜잭션 43이 커밋하려고 할 시점에는 이미 42가 커밋된 상태다.
        - 즉, 43 입장에선 전제(호출 대기 의사가 2명 이상임)가 깨진 상태
        - 일관된 스냅숏에서 읽을 때는 무시됐던 쓰기가 지금은 영향이 있고 이 때문에 43의 전제가 더 이상 참이 아니게 되었다.
    - 이런 이상 현상을 막으려면 **DB는 트랜잭션이 다른 트랜잭션의 쓰기를 무시하는 경우를 추적해야 한다**. (MVCC 가시성 규칙에 따라 무시되는 쓰기)
    - 트랜잭션이 **커밋하려고 할 때 DB는 무시된 쓰기 중에 커밋된게 있는지 확인**해야 한다.
    - 커밋된게 있다면 트랜잭션을 어보트시킨다.
- **과거의 읽기에 영향을 미치는 쓰기 감지하기**
    - 데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 **변경했을 때 감지하여 알려줄 수 있어야** 한다.
    
    ![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/493f9701-9bd7-48b6-8670-39a9c5b1a364)
    
    - shift_id에 색인이 있으면 DB는 색인 항목 1234를 사용해 42, 43이 데이터를 읽었다는 사실을 기록할 수 있다. (색인 범위 잠금)
    - 43은 42에게 전에 읽은 데이터가 뒤처졌다고 알려주고, 42도 43에게 알려준다.
    - 42가 먼저 커밋을 시도해 성공한다.
    - 43이 커밋하려고 시도하면 42의 충돌되는 쓰기가 이미 커밋됐으므로 43은 어보트돼야 한다.
- **직렬성 스냅숏 격리의 성능**
    - 직렬성 스냅숏 격리의 **트레이드오프는 읽기 쓰기를 추적하는 세밀함의 정도**
        - 각 트랜잭션의 동작을 매우 상세히 추적하면
            - 장점: 어보트돼야 하는 트랜잭션을 정확히 판별할 수 있다.
            - 단점: 기록 오버헤드가 심해질 수 있다.
        - 각 트랜잭션의 동작을 덜 상세히 추적하면
            - 장점: 성능이 빨라진다.
            - 단점: 필요한 것 보다 지나치게 많은 트랜잭션이 어보트될 수 있다.
    - 2단계 잠금과 비교
        - 직렬성 스냅숏 격리는 2단계 잠금과 달리, 잠금을 기다리느라 차단될 필요가 없다.
        - 스냅숏 격리와 마찬가지로 쓰는 쪽은 읽는 쪽을 막지 않고, 반대도 마찬가지
    - 순차 실행과 비교
        - 직렬성 스냅숏 격리는 단일 CPU 코어의 처리량에 제한되지 않는다.
        - 여러 장비에 파티셔닝돼 있어도 트랜잭션은 직렬성 격리를 보장한다.
    - **어보트 비율**은 SSI의 전체 성능에 가장 큰 영향을 미친다.
        - 오래 데이터를 읽고 쓰는 트랜잭션일 수록 충돌, 어보트되기 쉽다.
        - 따라서 SSI는 읽기 쓰기 트랜잭션이 짧기를 요구한다.
        - 그럼에도 2단계 잠금, 순차 실행보다는 느린 트랜잭션에 덜 민감하다.

## 정리

- 트랜잭션의 핵심
    - **동시성 문제와 여러 결함이 없는 것처럼** 추상화시켜준다.
    - 트랜잭션을 어보트시킴으로써 많은 오류가 간단해지고 **재시도**가 쉬워진다.
- 트랜잭션이 없으면 다양한 오류 시나리오로 데이터 일관성이 깨질 수 있다.
    - 프로세스가 죽거나, 네트워크가 끊기거나, 정전, 디스크 full, 동시성 문제 등
- 동시성 제어에 관한 내용
    - 격리 수준, 커밋 후 읽기, 스냅숏 격리, 직렬성 격리, 경쟁 조건의 다양한 예시
    - **더티 읽기**
        - 다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 읽는 것
        - “커밋 후 읽기”나 그보다 강한 격리 수준으로 방지해야 한다.
    - **더티 쓰기**
        - 다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 덮어쓰는 것
        - 거의 모든 트랜잭션 구현은 더티 쓰기를 방지한다.
    - **읽기 스큐(비반복 읽기)**
        - 다른 시점에 DB의 다른 부분을 보는 것
        - 해결책으로 스냅숏 격리를 흔히 사용한다.
        - 스냅숏 격리는 보통 **다중 버전 동시성 제어(MVCC)** 를 써서 구현한다.
    - **갱신 손실**
        - 두 클라이언트가 **read-modify-write 주기**를 실행한다. (동시 카운트 등)
        - 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않고 덮어써서 데이터 손실
        - 스냅숏 격리 구현으로 자동으로 막을 수 있으나 그렇지 않은 경우엔 수동 잠금이 필요하다. (SELECT FOR UPDATE)
    - **쓰기 스큐**
        - 트랜잭션이 *읽고 읽은 값을 기반으로 결정을 하고 그 결정을 쓰는* 주기를 실행한다.
        - 그러나 **쓰기를 실행하는 시점에서 결정의 “전제”가 더 이상 참이 아닌 경우**다. (호출 대기 중인 의사가 2명 이상이다.)
        - **직렬성 격리**만 이런 이상 현상을 막을 수 있다.
    - **팬텀 읽기**
        - 트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다.
        - 다른 클라이언트가 그 **검색 결과에 영향을 주는 쓰기를 실행**한다.
        - **스냅숏 격리**는 간단한 팬텀 읽기는 막아주지만,
        - 쓰기 스큐 맥락에서 발생하는 팬텀은 **색인 범위 잠금** 등의 처리가 필요하다.
- 완화된 격리 수준은 이런 이상 현상 중 일부는 막아주지만 나머지는 애플리케이션에서 수동으로 처리해야 한다. (명시적인 잠금 등)
- **직렬성 격리**만이 이 모든 문제로부터 보호해준다.
- 직렬성 트랜잭션을 구현하는 세 가지 방법
    - **말 그대로 트랜잭션을 순서대로 실행하기**
        - 트랜잭션의 실행 시간이 아주 짧고 처리량이 단일 CPU 코어에서 처리할 수 있을 정도라면 간단하고 효과적인 선택이다.
    - **2단계 잠금**
        - 수십년간 직렬성 구현의 표준이었지만 성능이 처참하여 현재는 사용을 피하는 경우가 많다.
    - **직렬성 스냅숏 격리(SSI)**
        - 낙관적 방법을 사용하여 트랜잭션이 차단되지 않고 진행할 수 있게 해준다.
        - 트랜잭션이 커밋을 원할 때 트랜잭션을 확인하여 실행이 직렬적이지 않다면 어보트시킨다.
