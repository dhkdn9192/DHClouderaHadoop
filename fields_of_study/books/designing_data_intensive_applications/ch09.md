# 09장 - 일관성과 합의

- 8장에서 살펴본대로 분산 시스템에선 많은 것들이 잘못될 수 있다.
- 결함이 있더라도 서비스가 올바르게 동작하게 **견뎌낼(tolerating)** 수 있어야 한다.
- 내결함성있는 시스템을 구축하는 최선의  방법은 유용한 보장을 해주는 범용 추상화를 찾아 구현하고, 애플리케이션에서 이 보장에 의존하도록 하는 것.
    - 7장의 트랜잭션을 사용함으로써 원자성, 격리성, 지속성을 갖는 것처럼
- 분산 시스템의 가장 중요한 추상화 중 하나는 **합의**이다. 즉, 모든 노드가 어떤 것에 동의하도록 만드는 것
    - 합의 구현은 다양한 목적으로 사용될 수 있다.
    - 리더가 죽었을 때 **새 리더를 선출**하는데 사용
    - **스플릿 브레인(split brain)** 문제 해결 등

## 일관성 보장

- 복제가 적용된 DB에서 동시에 노드 두 대를 본다면 서로 다른 데이터를 볼 가능성이 크다.
- 복제 DB는 대부분 최소한 **최종적 일관성**을 제공한다.
    - 불일치는 일시적이며, 결국 스스로 해소한다.
    - **매우 약한 보장**으로 언제 해소될지 모름
- 데이터 시스템이 선택할 수 있는 **더 강한 일관성 모델**을 살펴보자.
- 분산 일관성 모델과 트랜잭션 격리 수준 계층 비교
    - 트랜잭션 격리는 주로 동시 실행에 대한 **경쟁 조건을 회피**하는 것에 집중
    - 분산 일관성은 지연, 결함이 있더라도 **복제본의 상태를 코디네이션**하는 것에 집중

## 선형성

- 데이터 **복사본이 하나만 있는 것처럼 동작**하고, 그 데이터에 실행되는 모든 **연산이 원자적**이라는 것을 의미 → 복제 지연을 걱정할 필요가 없어짐
- 선형성의 정의는 미묘하며 다음과 같은 용어로도 불린다.
    - 원자적 일관성(atomic consistency)
    - 강한 일관성(strong consistency)
    - 즉각 일관성(immediate consistency)
    - 외부 일관성(external consistency)
- **최신성 보장(recency guarantee)**
    - 선형성 시스템에선 클라이언트가 쓰기를 완료하자마자 모든 읽기는 방금 쓰여진 값을 볼 수 있어야 한다.

### 시스템에 선형성을 부여하는 것은 무엇인가?

- 선형성을 이해하기 위해 예시를 차례대로 살펴보자

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/05b5b7dd-45c7-4044-9611-207ac461b306)

- (예시1) 값 x를 레지스터라 하며, 레지스터에 대한 두 가지 연산이 존재한다.
    - `read(x) => v` : x를 읽어 v를 반환
    - `write(x, v) => r` : x를 v로 설정하여 응답 r을 반환(ok 또는 error)
    - write 도중의 read 연산들은 오래된 값(0)과 새로운값(1) 사이를 왔다갔다하며 반환하게 되며 이는 “데이터의 단일 복사본”을 모방하는 시스템에 기대하는 바가 아니다. → 선형적이지 않다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/db68b164-68f5-4130-9576-3a2cbf59ed02)

- (예시2) 시스템을 선형적으로 만들기 위해 제약 조건을 추가한다.
    - 선형성 시스템에선 레지스터의 값이 원자적으로 바뀌는 시점이 있다.
    - 한 클라이언트의 읽기가 새로운 값(1)을 반환하면, 이후의 모든 읽기 또한 그 새로운 값을 반환해야 한다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/d7ddd02c-081d-470c-83f2-f7daeccfaf2e)

- (예시3) 읽기, 쓰기 외 세 번째 연산을 추가한다.
    - `cas(x, v_old, v_new) => r` : compare-and-set 연산을 의미. 레지스터 x가 v_old와 같으면 v_new로 설정한다. 아니라면 오류 반환
    - 선형성의 요구사항은 연산표시를 모은 선들이 항상 **시간순으로 진행**되며 결코 **뒤로 가서는 안 된다**는 것
    - B의 마지막 read는 선형적이지 않다. 직전 마지막 읽기가 A의 4였다. 즉, 4보다 과거의 값을 읽었으니 선형적이지 않다는 것.
- 선형성과 직렬성
    - 직렬성 : 트랜잭션들의 격리 속성
    - 선형성 : 읽기와 쓰기에 대한 최신성 보장. 선형성은 연산을 트랜잭션으로 묶지 않으므로 쓰기 스큐 같은 문제를 막지 못 한다. (충돌 구체화 등 부가적인 수단 필요)

### 선형성에 기대기

- 선형성이 중요한 요구사항이 되는 영역들을 살펴보자.
- **잠금과 리더 선출**
    - 단일 리더 복제 시스템에선 리더가 하나만 존재하도록 보장해야 한다.
    - 리더 선출에 **잠금**을 사용한다. (모든 노드가 잠금 획득을 시도하여 성공한 노드가 리더가 됨)
    - 이 잠금은 **선형적**으로 구현되어야 한다.
    - 분산 잠금, 리더 선출에 사용되는 코디네이션 서비스
        - Apache ZooKeeper, etcd 등
        - Oracle Real Application Cluster (RAC) → 분산 잠금
- **제약 조건과 유일성 보장**
    - 사용자명, 이메일 주소 등은 사용자 한 명을 유일하게 식별할 수 있어야 한다.
    - 이러한 유일성 제약 조건을 강제하려면 선형성이 필요하다.
    - 잠금과 유사한 점 : 가입 시 선택한 사용자명에 “잠금”을 획득한 것과 동일
    - 그 연산은 원자적 compare-and-set 과도 매우 비슷
- **채널 간 타이밍 의존성**
    - 선형성 위반은 시스템에 부가적인 통신 채널이 있기 때문에 발견된다.
    - 이미지를 업로드할 수 있는 웹사이트의 예시를 보자. 이 서비스에는 이미지를 저해상도로 크기를 바꾸는 백그라운드 프로세스가 존재한다. (썸네일용)
    - 파일 저장 서비스가 선형적이면 시스템은 잘 동작한다.
    - 선형적이지 않다면 **경쟁 조건**의 위험이 있다.
        - “메시지 큐”가 파일 저장소 “내부의 복제”보다 빠른 경우
        - 이 경우, 변경 모듈이 이미지의 과거 버전을 보거나 아무것도 보지 못 할 수 있다.
        - 이 문제는 웹 서버와 크기 변경 모듈 사이에 **두 가지 서로 다른 통신 채널** (파일 저장소, 메시지 큐) 가 있기 때문에 발생한다.
    - 즉, 선형성의 최신성 보장이 없으면 두 채널 사이에 경쟁 조건이 발생할 수 있다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/310ae15f-1d35-426e-a2a2-9dff54bf6bfd)


### 선형성 시스템 구현하기

- 시스템 내결함성을 위해 복제를 사용하면서 선형적으로 구현할 수 있을지 비교해보자.
- **단일 리더 복제 (선형적이 될 가능성 있음)**
    - 리더는 쓰기용, 팔로워는 백업 복사본을 저장
    - 리더, 혹은 동기식 갱신된 팔로워로부터의 읽기는 **선형적이 될 가능성**이 있다.
        - 설계(e.g. 스냅숏 격리를 사용) 혹은 동시성 버그 때문에 선형적이지 않을 수 있다.
        - 리더가 아닌 노드가 스스로를 리더라고 잘못 알고 행동하면 선형성을 위반하기 쉽다.
        - 비동기 복제를 사용하면 장애 복구 시 커밋된 쓰기가 손실 → 지속성과 선형성을 모두 위반
- **합의 알고리즘 (선형적)**
    - 합의 프로토콜은 스플릿 브레인과 복제본이 뒤처지는 문제를 막을 수단을 포함한다.
    - 따라서 선형성 저장소를 안전하게 구현할 수 있다.
- **다중 리더 복제 (비선형적)**
    - 여러 노드에서 동시에 쓰기를 처리하고 그렇게 쓰여진 내용을 비동기로 다른 노드에 복제 → 선형적이지 않다.
- **리더 없는 복제 (아마도 비선형적)**
    - 일 기준 시계를 기반으로 한 “최종 쓰기 승리” 충돌 해소 방법은 비선형적이다.
        - 시계 타임스탬프는 시계 스큐(clock skew) 때문에 이벤트의 실제 순서와 일치하지 않을 수 있다.
    - 느슨한 정족수도 선형성의 가능성을 망친다.

### 선형성과 정족수

- **다이나모 스타일** 모델에서 **엄격한 정족수**를 사용한 읽기, 쓰기는 선형적인 것처럼 보일 수 있으나, 네트워크 지연이 심하면 **경쟁 조건**이 생길 수 있다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/b54e6945-c76e-4a3e-842d-0c3ec0166999)

- 엄격한 정족수를 사용하지만 비선형적인 실행 예시
    - 쓰기 클라이언트가 세 복제본에 모두 쓰기 요청 (`n = 3, w = 3`)
    - 읽기 클라이언트는 두 노드 정족수로부터 읽는다. (`r = 2`)
    - 정족수 조건이 만족(`w + r > n`) 됨에도 이 실행은 선형적이지 않음
- 결론은, 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 봐야 한다. (엄격한 정족수와 선형성은 딱히 상관 없다고 봐야..)

### 선형성의 비용

- 여러 데이터센터에 분산된 데이터베이스에 대해서 센터간 네트워크가 끊기는 경우를 고려해보자
    - 다중 리더 데이터베이스 :
        - 각 데이터센터는 계속 정상 동작한다.,
        - 비동기로 다른 데이터센터에 복제되므로 네트워크 복구 시 큐에 쌓였던 복제가 전달된다.
    - 단일 리더 복제 :
        - 리더가 특정 데이터센터에만 있고 그 센터로 모든 쓰기와 선형성 읽기가 보내져야 한다.
        - 센터간 네트워크가 끊기면 리더로 연결할 수 없으므로 DB에 아무것도 쓸 수 없고, 선형성 읽기도 할 수 없다.
        - 클라이언트가 리더로 직접 접속할 수 있다면 정상 동작 가능하지만 그렇지 않다면 네트워크 복구까지 중단을 경험하게 된다.

### CAP 정리

- CAP : 네트워크 분단이 생겼을 때 **일관성**과 **가용성** 중 하나를 선택해야 한다는 트레이드오프를 의미
- 애플리케이션이 **선형성을 요구**하는 경우
    - 다른 복제 서버와 연결이 끊기면 요청을 처리할 수 없다.
    - 네트워크가 고쳐질 때까지 기다리거나 오류를 반환해야한다.
    - 즉, **가용성을 포기**해야 한다.
- 애플리케이션이 **선형성을 요구하지 않는** 경우
    - 연결이 끊기더라도 복제 서버는 독립적으로 요청을 처리한다.
    - 네트워크 문제에도 **가용한 상태를 유지**한다.
    - 그러나 그 동작은 선형적이지 않다.
- 즉, **선형성을 요구하지 않는 애플리케이션은 네트워크 문제에 더 강인**하다.

### 선형성과 네트워크 지연

- 선형성은 유용한 보장이지만 느리기 때문에 현실에서 선형적인 시스템은 드물다.
- 즉, 선형성을 제거하게 되는 이유는 내결함성이 아니라 **성능**이다.
    - 지연의 변동이 심한 네트워크 환경에선 선형성 읽기와 쓰기의 “응답 시간”은 필연적으로 높아진다.
- 선형성을 제공하는 빠른 알고리즘은 존재하지 않지만, 완화된 일관성 모델은 훨씬 빠를 수 있다.

## 순서화 보장

- 선형성 레지스터는 복사본이 하나만 있는 것처럼 동작하며, **모든 연산이 정의된 순서대로 실행**된다는 것을 의미한다.
    - 7장의 트랜잭션 직렬성을 실현하는 방법은 2가지다. 트랜잭션을 직렬적인 순서로 실행하거나, 동시 실행을 허용하지만 직렬성 충돌을 막는(잠금, 어보트) 방법이 있다.
    - 8장의 타임스탬프와 시계는 두 쓰기 중 어느 것이 나중에 일어났는지를 결정하는데 사용된다.
- 순서화, 선형성, 합의 사이에는 깊은 연결 관계가 존재한다.

### 순서화와 인과성

- 순서화는 인과성을 보존하는데 도움을 준다.
    - 대화의 관찰자 입장에서 응답을 먼저 보고 질문을 보게 되는 것은 혼란스럽다. 질문과 답변 사이에 **인과적 의존성(causal dependency)** 이 있기 때문.
    - 여러 리더 사이 복제에서 네트워크 지연으로 어떤 쓰기가 다른 쓰기를 추월(존재하지 않는 로우를 갱신) 하는 등 인과성을 위반한 사례가 있을 수 있다.
    - 트랜잭션의 스냅숏 격리에서 “일관된 스냅숏“에 사용된 일관적의 의미는 **인과성에 일관적(consistent with causality)** 이라는 의미이다.
    - 직렬성 스냅숏 격리(SSI)는 트랜잭션 사이의 인과적 의존성을 추적함으로써 쓰기 스큐를 검출한다.
- 인과성은 이벤트에 순서를 부과한다.
- 시스템이 인과성에 의해 부과된 순서를 지키면, 그 시스템은 **인과적으로 일관적(causally consistent)** 이라고 한다.
    - 예를 들어 스냅숏 격리는 인과적 일관성을 제공한다.

### 인과적 순서가 전체 순서는 아니다

- **전체 순서(total order)** : 어떤 두 요소를 비교할 수 있게 해준다.
- 그러나 수학적 집합은 항상 전체 순서정해지는 것이 아니며, **부분적으로 순서가 정해진다(partially ordered)**
    - 선형성
        - 연산의 전체 순서를 정할 수 있다.
    - 인과성
        - 두 연산 중 먼저 실행된 것이 없다면 두 연산이 **동시적**이라 말한다.
        - 두 이벤트 사이 인과적 관계가 있으면 순서가 존재한다. 반면, 동시에 실행되면 비교를 할 수 없다.
        - 즉, **인과성**은 전체 순서가 아닌 **부분 순서**를 정의한다.
- 이 정의에 따라 선형성 데이터스토어에는 동시적 연산이 없다.
    - 하나의 타임라인을 따라 모든 연산의 전체 순서가 정해져야 한다.

### 선형성은 인과적 일관성보다 강하다

- 선형성은 인과성을 **내포한다**.
    - 선형적인 시스템이라면 인과성도 올바르게 유지한다.
- 선형적인 시스템은 네트워크 지연이 크면 성능과 가용성이 크게 떨어지므로, 분산 시스템에선 선형성을 포기하기도 한다.
- 그러나 선형성은 인과성을 보존하기 위한 유일한 방법이 아니다.
    - **선형성으로 인한 성능 손해 없이 인과적 일관성을 만족시킬 수 있다**.
    - 선형성이 요구되는 많은 경우에서 **실제로 필요한것은 인과적 일관성**이며, 이는 더 효율적으로 구현될 수 있다.

### 인과적 의존성 담기

- **비선형적인 시스템**이 어떻게 **인과적 일관성**을 유지할 수 있을까?
- 인과성을 유지하려면 어떤 연산이 다른 연산보다 먼저 실행됐는지 알아야 한다. → **부분 순서**
    - 복제 서버가 연산을 처리할 때 인과적으로 앞서는 모든 연산이 이미 처리됐다고 보장할 수 있어야 한다.
    - 후속 연산은 선행 연산이 처리될 때까지 기다려야 한다.
- 인과적 의존성은 전체 DB에 걸친 인과적 의존성을 추적해야 한다. 이를 위해 **버전 벡터(version vector)** 를 일반화할 수 있다.
    - 인과적 순서를 결정하기 위해 DB는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 한다.

### 일련번호 순서화

- 모든 인과적 의존성을 추적하는 것은 오버헤드가 커서 실용성이 떨어진다.
- 때문에 **일련번호**나 **타임스탬프**를 써서 **이벤트의 순서**를 정할 수 있다.
- 타임스탬프는 일 기준 시계(문제가 많은 물리적 시계)에서 얻을 필요 없이 **논리적 시계**에서 얻으면 된다.
- 논리적 시계는 **연산을 식별하는 일련번호**를 생성하며, 연산마다 **단조증가**한다.
- 단일 리더 복제의 예시
    - 리더는 연산마다 카운터를 증가시키고 복제 로그의 각 연산에 단조 증가하는 일련번호를 할당한다.
    - 그럼 팔로워가 복제로그의 순서대로 쓰기를 적용하면 팔로워는 언제나 **인과성에 일관적**이다. (리더보다 뒤처질 수는 있지만)

### 비인과적 일련번호 생성기

- 다중 리더나 리더 없는 복제 등 단일 리더가 아닌 경우에 일련번호를 생성하는 방법
    1. 각 노드가 일련번호의 이진 표현에서 특정 비트를 예약하여 고유 노드 식별자를 포함하는 방법.(A노드는 짝수, B노드는 홀수만 사용) 이 경우, 서로 다른 노드가 같은 일련번호를 생성하지 않는다고 보장할 수 있다.
    2. 충분히 해상도가 높은 일 기준 시계를 사용하면 전체 순서를 정하는데 충분할 수 있다. → 단, 물리적 시계의 시계 스큐 문제 존재
    3. 일련번호 블록을 미리 할당하는 방법. (1부터 1000는 A노드, 1001부터 2000은 B노드 인 방식) → 단, 뒷 블록 일련번호를 받은 연산이 실제로는 먼저 수행될 수도..
- 위 방식들은 모두 잘 동작하며, 단일 리더 방식에 비해 확장성도 좋다.
- 그러나 여러 노드에 걸친 연산들의 **순서를 올바르게 담지 못해** **인과성에 일관적이지 않다**는 문제가 있다.

### 램포트 타임스탬프

- 인과성에 일관적인 일련번호를 생성하는 간단한 방법
- 램포트 타임스탬프(Lamport timestamp) 논문은 분산 시스템 분야에서 가장 많이 인용된 논문 중 하나이다.
- 규칙
    - 각 노드는 고유 식별자(노드ID)와 처리한 연산 개수 카운터를 갖는다.
    - 즉, 램포트 타임스탬프는 (카운터, 노드ID) 쌍
    - 두 타임스탬프가 있으면 카운터가 큰 것이 타임스탬프가 크다.
    - 카운터 값이 같으면 노드ID가 큰 것이 타임스탬프가 크다.
    - 모든 노드, 클라이언트는 지금까지 본 카운터 값 중 최댓값을 추적하고, 모든 요청에 그 최댓값을 포함시킨다.
- 두 노드의 카운터가 같더라도 노드ID로 구분되므로 각 타임스탬프는 유일하다.
- **모든 인과적 의존성이 타임스탬프를 증가**시키므로 타임스탬프로부터 얻은 순서는 **인과성에 일관적**이도록 보장해준다.
- 버전 벡터가 두 연산의 동시성, 인과적 의존성 구분에 사용된다면 **램포트 타임스탬프는 항상 전체 순서화를 강제**한다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/5fb93c4f-c831-41da-965a-6b79f220310f)

### 타임스탬프 순서화로는 충분하지 않다

- 램포트 타임스탬프가 인과성에 일관적인 전체 연산의 순서를 정의하지만 분산 시스템의 특정 문제를 해결하는데에는 충분하지 않다.
- 사용자명 등록 시 계정을 유일하게 식별할 수 있어야 하는 시스템의 예
    - 램포트 타임스탬프는 사후에, 즉 사용자명 생성 **연산을 모두 모은 후에야 그들의 타임스탬프를 비교할 수 있다**.
    - 사용자명 생성 요청을 받고 **당장** 성공, 실패를 결정해야 할 때는 이 방법으론 부족하다.
- 문제점은, 연산의 전체 순서는 모든 연산을 모은 후에야 알 수 있다는 것이다.
- 결론은, 사용자명에 대한 유일성 제약 조건을 구현하려면 **연산의 전체 순서만으론 충분하지 않다**. **언제 그 순서가 확정되는지도 알아야 한다**.
- 언제 전체 순서가 확정되는지는 전체 순서 브로드캐스트에서 알아보자.

### 전체 순서 브로드캐스트

- 단일 리더 복제는 연산의 전체 순서를 정할 수 있지만 문제점이 있다.
    - 단일 리더가 처리하기 어려운 처리량에 대해 **어떻게 시스템을 확장**할 것인가
    - 리더에 장애가 발생했을 때 **어떻게 장애 복구**할 것인가.
    - → **전체 순서 브로드캐스트(total order broadcast)** 또는 **원자적 브로드캐스트(atomic broadcast)** 문제로 알려져 있다.
- 전체 순서 브로드캐스트는 두 가지 안전성 속성을 항상 만족해야 한다.
    - **신뢰성 있는 전달(reliable delivery)**
        - 어던 메시지도 손실되지 않는다. 한 노드에 전달되면 모든 노드에도 전달된다.
    - **전체 순서가 정해진 전달(totally ordered delivery)**
        - 메시지는 모든 노드에 같은 순서로 전달된다.

### 전체 순서 브로드캐스트 사용하기

- 주키퍼, etcd 와 같은 **합의 서비스**는 **전체 순서브로드캐스트를 구현**한다.
- **상태 기계 복제(state machine replication)**
    - 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는 상태를 유지한다.
- 전체 순서 브로드캐스트는 **직렬성 트랜잭션을 구현하는데에도** 쓸 수 있다.
- 전체 순서 브로드캐스트는 메시지 전달 시점에 순서가 고정되므로 **후속 메시지를 순서 앞에 소급적으로 끼워넣는게 허용되지 않는다**. → 타임스탬프 순서화보다 강하다.
- 전체 순서 브로드캐스트는 **펜싱 토큰을 제공하는 잠금 서비스 구현에도 유용**하다.
    - 주키퍼에선 `zxid` 일련번호가 단조 증가 펜싱 토큰의 역할 수행

### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

- 선형성과 전체 순서 브로드캐스트는 동일하진 않지만 밀접한 관계가 있다.
- 전체 순서 브로드캐스트는 **비동기식**이다.
    - 메시지는 고정된 순서로 신뢰성 있게 전달되지만
    - **언제** 메시지가 전달될지는 보장 안 함
    - 반면, 선형성은 최신성 보장이다. (읽기가 최근에 쓰여진 값을 보는게 보장됨)
- 그러나 전체 순서 브로드캐스트를 사용해 선형성 저장소를 만들 수 있다.
- 사용자 계정을 유일하게 식별하는 시스템 예시
    - 사용 가능한 모든 사용자명마다 원자적 **compare-and-set 연산** 구현
    - 모든 레지스터는 초기엔 null 값을 가짐
    - 여러 사용자가 동시에 같은 사용자명을 가지려 하면 compare-and-set 연산 중 하나만 성공하며 다른 연산들은 null이 아닌 값을 보게되므로 실패함
- 메시지가 **모든 노드에 같은 순서로 전달**되므로 여러 쓰기가 동시에 실행되면 **모든 노드가 어떤 쓰기가 먼저 실행된 것인지 동의**한다.
- 이런 방식은 **선형성 쓰기를 보장**하지만 **선형성 읽기는 보장하지 않는다**.
    - 비동기로 갱신되는 저장소를 읽으면 오래된 값을 읽게될 수 있다.
    - 읽기를 선형적으로 만들려면 추가 작업 필요

### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기

- 가장 쉬운 방법은 정수를 저장하고 원자적 increment-and-get 연산이 지원되는 선형성 레지스터가 있다고 가정하는 것이다.
    - 보낼 모든 메시지에 대해 선형성 정수로 increment-and-get 연산을 수행 후
    - 레지스터에서 얻은 값을 일련번호로 메시지에 붙인다.
    - 수신자는 일련번호 순서대로 메시지를 전달한다.
- 이렇게 increment-and-get 연산이 지원되는 선형성 정수를 만드는 것은 **어렵다**.
    - 네트워크 연결이 끊기거나 노드 장애 시 값을 복구하는게 문제 등
- 때문에 **선형성 일련번호 생성기**에 대해 고심하다 보면 필연적으로 **합의 알고리즘에 도달**하게 된다.
    - 선형성 compare-and-set(또는 increment-and-get) 레지스터와 전체 순서 브로드캐스트는 둘 다 합의와 동등하다고 증명할 수 있다.

## 분산 트랜잭션과 합의

- 합의의 목적 : **여러 노드들이 뭔가에 동의하게 만드는 것**
- 합의를 이해하기 위한 선행 지식 : 복제, 트랜잭션, 시스템 모델, 선형성, 전체 순서 브로드캐스트
- 노드가 동의하는 것이 중요한 상황
    - **리더 선출**
        - 단일 리더 복제에선 모든 노드가 누가 리더인지 동의해야 한다.
        - 네트워크 결함 시 리더십 지위를 놓고 경쟁할 수 있다.(스플릿 브레인)
    - **원자적 커밋**
        - 여러 노드나 파티션에 걸친 트랜잭션은 일부 노드에서 성공, 나머지에선 실패할 위험이 있다.
        - 원자성(ACID) 을 유지하려면 모든 노드가 트랜잭션 결과에 동의하게 만들어야 한다.
- 합의 불가능성
    - FLP 결과에 따르면 어떤 노드가 죽을 위험이 있다면 항상 합의에 이를 수 있는 알고리즘은 없다.
    - 그러나 이는 시계나 타임아웃을 사용할 수 없는 매우 제한된 모델에서의 증명이다.
    - 따라서 타임아웃, 죽은 노드 식별 방법 등이 있다면 합의는 해결 가능한 문제다.

### 원자적 커밋과 2단계 커밋(2PC)

- 7장에서 배운 트랜잭션의 원자성은 부분적 완료, 갱신으로 DB가 오염되는 것을 막아준다.
- 원자성은 (주 데이터와 분리된) **보조색인도 주 데이터와 일관성을 유지하도록 보장**해주므로 중요하다.

### 단일 노드에서 분산 원자적 커밋으로

- 분산 시스템에서 각 노드에 트랜잭션 커밋 요청을 보내면 노드별로 커밋 성공, 실패 여부에 따라 **원자성 보장을 위반**할 수 있다.
    - 어떤 노드는 제약 조건 위반, 충돌 감지로 어보트
    - 어떤 커밋 요청은 네트워크에서 손실
    - 어떤 노드는 커밋 레코드가 완전히 디스크에 쓰여지기 전에 죽음
- 어떤 노드가 트랜잭션을 커밋하고 다른 노드는 어보트한다면 노드들이 서로 **일관성이 없어진다**.
- 한 노드에서 한 번 커밋되면 다시 취소할 수 없고 소급적으로 어보트될 수 없다.
    - **커밋 후 읽기** 격리의 기반이므로
- 따라서 각 노드는 트랜잭션에 참여하는 **다른 모든 노드도 커밋될 것이라고 확신할 때에만 커밋이 돼야 한다**.

### 2단계 커밋 소개

- 2단계 커밋 : 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성하는, 즉 **모든 노드가 커밋되거나 모든 노드가 어보트되도록 보장**하는 알고리즘
- 2PC의 커밋, 어보트 과정은 두 단계로 나뉜다.
- 단일 노드 트랜잭션에는 없는 **코디네이터(트랜잭션 관리자)** 라는 컴포넌트를 사용한다.
- 데이터베이스 노드를 트랜잭션의 **참여자(participant)** 라 부른다.
- 애플리케이션이 커밋할 준비가 되면 코디네이터가 각 노드에 **준비** 요청을 보내서 커밋할 수 있는지 물어본다.
    - 모든 참여자가 커밋할 준비가 됐다고 응답하면 코디네이터는 2단계에서 커밋 요청을 보내고 커밋이 이뤄진다.
    - 참여자 중 하나라도 아니오 라고 응답하면 2단계에서 모든 노드에 어보트 요청을 보낸다.

![image](https://github.com/dhkdn9192/data_engineer_career/assets/11307388/53380263-4ff7-4857-952f-5bd8a1ac5fdc)


### 약속에 관한 시스템

- 2PC의 동작 과정 상세 (자세한 설명은 생략)
    - 코디네이터는 모든 참여자에게 준비 요청을 보내고, 응답을 받으면 트랜잭션을 커밋할지 어보트할지 **최종적 결정**을 한다.
    - 추후 죽더라도 어떻게 결정했는지 알 수 있도록 디스크에 있는 트랜잭션 로그에 기록하는데 이를 **커밋 포인트**라 한다.
    - 커밋 포인트가 디스크에 쓰여지면 모든 참여자에게 커밋 or 어보트 요청이 전송된다. 요청이 타임아웃 등으로 실패하면 코디네이터는 **성공할 때까지 영원히 재시도**해야 한다.
- 이 프로토콜에는 **원자성 보장**을 위해 두 개의 중대한 “돌아갈 수 없는 지점”이 있다.
    - 참여자가 커밋 여부에 대해 yes or no라고 응답한 시점
    - 코디네이터가 최종적 결정을 내린 시점

### 코디네이터 장애

- 2PC 도중 참여자나 네트워크 장애 시 코디네이터는 트랜잭션을 어보트하거나 최종적 결정(커밋 or 어보트) 요청이 실패하면 무한히 재시도한다.
- 그러나 코디네이터가 죽으면
    - 참여자가 준비 요청에 대해 yes or no 응답을 했다면 일방적으로 커밋 or 어보트할 수 없다.
    - 코디네이터로부터 트랜잭션이 커밋 or 어보트됐는지 회신을 받을 때까지 **기다릴 수 밖에 없다**.
    - 이 상태에 있는 참여자의 트랜잭션을 **의심스럽다(in doubt)** 또는 **불확실하다(uncertain)** 라고 한다.
- 2PC가 완료할 수 있는 유일한 방법은 **코디네이터가 복구되기를 기다리는 것 뿐**이다.
- 이것이 코디네이터가 **최종적 결정을 디스크에 있는 트랜잭션 로그에 써야하는 이유**이다.
- 코디네이터가 복구될 때 트랜잭션 로그를 읽어서 모든 의심스러운 트랜잭션들의 상태를 결정한다.

### 3단계 커밋

- 2PC는 위처럼 코디네이터 복구를 기다리느라 멈출 수 있는 **블로킹** 원자적 커밋 프로토콜이라 불린다.
- 이론상 노드에 장애가 나도 멈추지 않는 원자적 커밋 프로토콜을 **논블로킹**하게 만들 수는 있으나, 현실적이지는 않다. → 때문에 2PC가 계속 쓰이고 있다.
- 3단계 커밋(3PC) 은 다음 상황을 가정한 알고리즘이다.
    - 지연에 제한이 있는 네트워크와
    - 응답 시간에 제한이 있는 노드
- 그러나 대부분의 실제 시스템에선 아래와 같으므로 **3PC는 원자성을 보장하지 못 한다**.
    - 기약 없는 네트워크 지연
    - 프로세스 중단
- 일반적으로 논블로킹 원자적 커밋은 **완벽한 장애 감지기(perfect failure detector)** 즉 노드가 죽었는지 아닌지 구별할 수 있는 신뢰성 있는 메커니즘이 필요하다. (보통 타임아웃이 사용됨)
- 그러나 현실의 기약 없는 지연이 있는 네트워크에서 **타임아웃은 신뢰성 있는 장애 감지기가 아니다**.

### 현실의 분산 트랜잭션

- 2PC로 구현된 분산 트랜잭션은 운영상의 문제와 무거운 성능 저하로 나쁜 평가를 받는다.
    - MySQL의 분산 트랜잭션은 단일 노드에 비해 10배 이상 느리다.
    - 2PC는 장애 복구를 위한 디스크 강제 쓰기, 부가적인 네트워크 왕복 시간이 성능 비용의 많은 부분을 차지한다.
- 이 때문에 여러 클라우드 서비스들은 분산 트랜잭션을 구현하지 않는 선택을 한다.
- 두 가지 분산 트랜잭션을 구분할 필요가 있다.
    - **데이터베이스 내부 분산 트랜잭션**
        - DB 노드 사이에 내부 트랜잭션을 지원한다.
        - 트랜잭션 참여자들이 모두 동일한 DB 소프트웨어를 실행한다.
        - 흔히 매우 잘 동작한다.
    - **이종 분산 트랜잭션**
        - **이종(heterogeneous)** 트랜잭션에서 참여자들은 서로 다른 기술이다.
        - 서로 다른 벤더 혹은 메시지 브로커처럼 DB 시스템이 아닐 수도 있다.
        - 서로 시스템 내부가 완전히 달라도 원자적 커밋을 보장해야 하므로 **훨씬 더 어렵다**.

### 정확히 한 번 메시지 처리

- 이존 분산 트랜잭션은 서로 다른 시스템을 강력한 방법으로 통합될 수 있게 한다.
- 메시지 브로커와 데이터베이스가 서로 다른 장비에서 실행되는 무관한 기술이더라도 이종 분산 트랜잭션으로 결합 가능하다.
    - 메시지 큐에서 나온 메시지는 이 메시지를 처리한 DB 트랜잭션이 커밋에 성공했을 때만 처리된 것으로 확인받을 수 있다.
- “메시지 전달”이나 “데이터베이스 트랜잭션” 중 하나가 실패하면 둘 다 어보트되고 메시지 브로커는 나중에 메시지를 안전하게 다시 전달한다.
- 메시지가 **결과적으로(effectively) 정확히 한 번(exactly once)** 처리되도록 보장할 수 있다. (성공하기까지 몇 번의 재시도가 필요할 수 있지만)
- 단, 이런 분산 트랜잭션은 모든 시스템이 동일한 원자적 커밋 프로토콜(2PC)을 사용할 수 있어야만 가능하다.

### XA 트랜잭션

- X/Open XA(eXtended Architecture) 는 이종 기술에 걸친 2PC를 구현하는 표준이다.
- 여러 전통적인 관계형 DB와 메시지 브로커에서 지원한다.
- XA는 네트워크 프로토콜이 아니다. 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 C API일 뿐이다.
- 트랜잭션 코디네이터는 트랜잭션을 시작하는 **애플리케이션과 같은 프로세스에서 로딩되는 단순한 라이브러리**다.
- 따라서 애플리케이션 프로세스나 장비가 죽으면 **코디네이터도 함께 사라진다**.
- 이 경우 준비됐지만 커밋되지 않은 트랜잭션들을 가진 참여자들은 의심스러운 상태에 빠진다.
- 코디네이터의 로그가 애플리케이션 서버의 로컬 디스크에 있으므로 그 서버가 재시작되어 코디네이터 라이브러리가 트랜잭션 로그를 읽고 각 트랜잭션의 커밋, 어보트 결과를 복구해야 한다.
- 모든 통신이 클라이언트 라이브러리를 거쳐야 하므로 **데이터베이스 서버는 코디네이터에 직접 연결할 수 없다**.

### 의심스러운 상태에 있는 동안 잠금을 유지하는 문제

- 트랜잭션이 의심스러운 상태에 빠지는 것을 신경쓰는 이유는 **잠금** 때문이다.
- DB 트랜잭션은 **더티 쓰기**를 막기 위해 변경한 로우에 대해 **독점적인 잠금**을 획득한다.
    - **직렬성 격리**를 원할 경우 **2단계 잠금**을 사용해 읽은 로우에 대해서도 **공유 잠금**을 획득해야 한다.
- 데이터베이스는 트랜잭션이 커밋 or 어보드될 때까지 이런 잠금을 해제할 수 없다.
- 따라서 2단계 커밋을 사용할 때 트랜잭션은 의심스러운 상태에 있는 내내 잠금을 잡고 있어야 한다.
- 이는 **의심스러운 트랜잭션이 해소될 때까지 애플리케이션이 동작할 수 없게되는 원인**이다.

### 코디네이터 장애에서 복구하기

- 코디네이터가 죽은 후 복구됐을 때 트랜잭션을 해소해야 하지만 실제로는 **고아가 된(orphaned) 의심스러운 트랜잭션**이 생길 수 있다.
    - 트랜잭션 로그가 손실, 오염되어서
- 이런 고아 트랜잭션은 자동으로 해소될 수 없어서 **잠금을 유지하고 다른 트랜잭션을 차단하면서 DB에 영원히 남는다**.
- DB 서버를 **재부팅해도 고쳐지지 않는다**.
    - 2PC의 올바른 구현은 재시작하더라도 의심스러운 트랜잭션의 잠금을 유지해야하기 때문
- 빠져나가는 유일한 방법은 **관리자가 수동으로 트랜잭션을 커밋, 롤백**하는 것 뿐이다.
- 여러 XA 구현에는 참여자가 코디네이터로부터 확정적 결정을 얻지 않고도 의심스러운 트랜잭션을 어보트, 커밋할지 일방적으로 결정할 수 있도록 **경험적 결정(heuristic decision)** 이라 부르는 비상 탈출구를 제공한다.
    - 2단계 커밋의 약속 체계를 위반하므로 **원자성을 깰 수도 있다**.
    - 평상시가 아니라 큰 장애 상황을 벗어나야하는 경우에만 쓰도록 의도된 것

### 분산 트랜잭션의 제약

- XA 트랜잭션은 여러 참여 데이터 시스템이 서로 일관성을 유지하게 해준다.
- 그러나 XA 트랜잭션도 여러 운영상 문제를 가진다.
    - 코디네이터가 단일 장비에서만 실행되면 **단일 장애점**이 된다. 놀랍게도 여러 코디네이터 구현은 기본적으로 고가용성을 제공하지 않는다.
    - 애플리케이션 서버는 추가, 제거가 자유로운 **상태 비저장 모드**로 개발된다. 그러나 코디네이터가 애플리케이션 서버의 일부분이 되면 **갑자기 시스템의 중대한 부분이 된다**. (더 이상 상태 비저장이 아니게 된다.)
    - 여러 시스템에 걸친 교착 상태를 감지할 수 없고, SSI (직렬성 스냅숏 격리) 와 함께 동작하지 않는다.

### 내결함성을 지닌 합의

- 합의는 여러 노드가 어떤 것에 동의해야 한다는 뜻
- 합의 문제는 노드들이 **값을 제안**하고 합의 알고리즘이 그 값 중 하나를 **결정**하는 형태로 형식화된다.
    - 좌석 예약 예시에서, 여러 고객이 동시에 같은 좌석을 구입하려하면 고객 요청 처리 노드들은 서비스하는 고객의 ID를 제안하고, 결정은 이 고객들 중 누가 구매하게 되는지를 가리킨다.
- 합의 알고리즘은 다음 속성을 만족해야 한다.
    - **균일한 동의**
        - 어떤 두 노드도 다르게 결정하지 않는다.
    - **무결성**
        - 어떤 노드도 두 번 결정하지 않는다.
    - **유효성**
        - 한 노드가 값 v를 결정한다면 v는 어떤 노드에서 제안된 것이다.
    - **종료**
        - 죽지 않은 모든 노드는 결국 어떤 값을 결정한다.
- 합의 알고리즘은 종료를 보장하려면 최소한 노드의 과반수가 올바르게 동작해야 한다.
- 대부분의 합의 알고리즘은 비잔틴 결함이 없다고 가정한다.

### 합의 알고리즘과 전체 순서 브로드캐스트

- 널리 알려진 내결함성 있는 합의 알고리즘 대다수는 전체 순서 브로드캐스트 알고리즘을 사용한다.
- 전체 순서 브로드캐스트를 하려면 모든 노드에게 메시지가 **정확히 한 번**, **같은 순서로 전달**돼야 한다.
- 이는 합의를 여러번 반복하는 것과 동일하다.
    - 각 회마다 노드들은 보낼 메시지를 **제안**하고
    - 전체 순서 상에서 전달될 다음 메시지를 **결정**한다.
- 다은 특성에서 동일한 점이 있다.
    - 합의의 “동의” 속성 때문에 모든 노드는 같은 메시지를 같은 순서로 전달한다.
    - “무결성” 속성 때문에 메시지는 중복되지 않는다.
    - “유효성” 속성 때문에 메시지는 오염, 조작되지 않는다.
    - “종료” 속성 때문에 메시지는 손실되지 않는다.

### 단일 리더 복제와 합의

- 모든 쓰기가 리더에게 전달되고 쓰기가 같은 순서로 팔로워에 적용되는 **단일 리더 복제**는 본질적으로 **전체 순서 브로드캐스트**와 같다.
- 리더에 장애가 발생하면 새로운 리더를 선출해야하는데 **스플릿 브레인 문제**를 해결하기 위해 **합의**가 필요하다.
- 합의 알고리즘이 실제로는 전체 순서 브로드캐스트와 같고, 전체 순서 브로드캐스트는 단일 리더 복제와 같고, 단일 리더 복제는 리더가 필요하다.
- 즉 리더를 선출하려면 먼저 리더가 필요하고, 합의를 해결하기 위해 합의를 해결해야하는 것처럼 보인다.
- 닭이 먼저냐 알이 먼저냐?

### 에포크 번호 붙이기와 정족수

- 합의 프로토콜에선 **에포크 번호(epoch number)** 를 정의하고 각 에포크 내에서는 **리더가 유일**하다고 보장한다.
- 리더 선출 투표는 에포크 번호를 **단조 증가**시키며, 다른 에포크에 있는 두 리더가 충돌하면 **에포크 번호가 높은 리더가 이긴다**.
- 리더가 뭔가 결정하기 전에 에포크 번호가 더 높은 다른 리더가 없는지 확인해야 한다.
- 리더는 자신이 다른 노드에 의해 쫓겨나지 않았는지를 **정족수 투표**를 통해 결정받아야 한다.
    - 즉, 리더는 내리려는 결정에 대해 제안된 값을 다른 노드에 보내서 노드의 정족수가 그 제안에 찬성한다고 응답하기를 기다려야 한다. (보통 과반수)
- 따라서 두 번의 투표가 있다.
    - 리더를 선출하는 투표
    - 리더의 제안에 투표
- 2단계 커밋과 차이점
    - 2PC에서 코디네이터는 선출되지 않는다.
    - 2PC는 모든 참여자로부터 yes or no 투표가 필요하지만 내결함성 있는 합의 알고리즘은 노드의 과반수로부터만 투표받으면 된다.

### 합의의 제약

- 합의 알고리즘은 분산 시스템에 많은 발전을 가져왔다.
    - 모든 것이 불확실한 시스템에 구체적인 안전성 속성 부여(동의, 무결성, 유효성)
    - 내결함성 유지(노드 과반수만 동작해도 진행 가능)
    - 전체 순서 브로드캐스트를 제공하므로 내결함성 있는 방식으로 선형성 원자적 연산을 구현할 수도 있다.
- 그럼에도 합의 알고리즘의 단점 때문에 모든 곳에 쓰이지는 않는다.
    - 제안을 결정하기 위한 투표 과정은 일종의 동기식 복제다. (성능 하락)
    - 합의 시스템은 엄격한 과반수가 동작하기를 요구한다.
    - 투표에 참여하는 집합이 고정돼 있어 클러스터에 노드를 추가, 제거하기가 쉽지 않다.
    - 합의 시스템에서 장애 노드 감지는 타임아웃에 의존하므로 잘못된 장애 탐지로 인한 잦은 리더 선출은 끔찍한 성능을 유발한다.
    - 때때로 합의 알고리즘은 네트워크 문제에 민감하다. 신뢰성 없는 네트워크에 더욱 견고한 알고리즘 설계는 여전히 해결되지 않은 연구 문제다.

### 멤버십과 코디네이션 서비스

- 주키퍼, etcd는 주어진 키에 대한 값을 읽거나 쓸 수 있고 키에 대해 순회할 수 있다. 기본적으로 데이터베이스와 유사해보인다.
- 그러나 주키퍼는 실제로 범용 데이터베이스에 적합하지 않아 애플리케이션 개발자가 직접 쓸 일이 거의 없다. 보통 다른 프로젝트를 통해서 간접적으로 의존하게 된다.
    - HBase, Hadoop YARN, OpenStack Nova, Kafka 등
- 주키퍼, etcd는 완전히 메모리 안에 들어올 수 있는 작은 양의 데이터를 보관하도록 설계됐다.
- 이 소량의 데이터는 내결함성을 지닌 전체 순서 브로드캐스트 알고리즘을 사용해 모든 노드에 복제된다.
- 주키퍼는 분산 시스템을 구축할 때 유용한 기능들을 제공한다.
    - **선형성 원자적 연산**
        - 원자적 compare-and-set 연산으로 잠금을 구현할 수 있다.
        - 분산 잠금은 보통 만료 시간이 있는 **임차권(lease)** 로 구현된다.
    - **연산의 전체 순서화**
        - 잠금, 임차권을 사용할 때 프로세스 중단으로 클라이언트들이 충돌하는 것을 막기 위해 **펜싱 토큰**이 필요하다.
        - 주키퍼는 모든 연산에 전체 순서를 정하고 각 연산에 단조 증가하는 **트랜잭션ID(zxid)** 와 **버전 번호(cversion)** 을 할당한다.
    - **장애 감지**
        - 클라이언트는 주키퍼 서버에 수명이 긴 세션을 유지하고, 주기적으로 하트비트(hearcbeat) 를 교환해서 다른 쪽이 살아있는지 확인한다.
    - **변경 알림**
        - 다른 클라이언트가 생성한 잠금과 값을 읽을 수 있을 뿐만 아니라, 거기에 변경이 있었는지도 감시할 수 있다.
        - 다른 클라이언트가 언제 클러스터에 합류했는지, 장애가 났는지 등을 알 수 있다.
        - 알림을 구독함으로써 주기적으로 폴링해야할 필요가 없어진다.

### 작업을 노드에 할당하기

- 주키퍼 모델이 잘 동작하는 예
    - 여러 프로세스나 서비스 중 하나가 리더 혹은 주 구성요소로 선택되어야 할 때
    - 파티셔닝된 자원이 있고 어떤 파티션을 어느 노드에 할당해야 할지 결정해야하는 경우
- 매우 많은 노드에서 과반수 투표를 수행하는 것은 매우 비효율적이다.
- 대신 주키퍼는 보통 3대, 5대 정도로 고정된 수의 노드에서 실행되고 이 노드들 사이에서 과반수 투표를 수행한다.
- 즉, 주키퍼는 코디네이트 작업을 외부 서비스에 위탁하는 방법을 제공하는 셈
- 보통 주키퍼로 관리되는 데이터의 종류는 매우 느리게 변한다.

### 서비스 찾기

- 주키퍼, etcd, Consul은 **서비스 찾기(service discovery)** 즉, 특정 서비스에 연결하려면 어떤 IP 주소로 접속해야 하는지 알아내는 용도로도 자주 사용된다.
- 가상장비가 지속적으로 들어왔다 나가는게 흔한 클라우드 환경에서 서비스의 IP 주소를 사전에 알지 못할 때

### 멤버십 서비스

- 주키퍼 등은 오랜 **멤버십 서비스(membership service)** 연구 역사의 일부로 볼 수 있다.
- 항공 교통 관제 같은 고신뢰성 시스템을 구축하기 위한 연구임
- 멤버십 서비스는 클러스터에서 어떤 노드가 살아있는 멤버인지 결정한다.
- **기약 없는 네트워크 지연** 때문에 노드에 장애가 생겼는지 **신뢰성 있게 감지하는 것은 불가능**하다.
- 그러나 장애 감지와 합의를 연결하면 어떤 노드가 살아있는 것으로 여겨져야 하는지 **동의**할 수 있다.
