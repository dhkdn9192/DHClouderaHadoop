# 스칼라 프로그래밍

## 1. 함수형 프로그래밍
- 함수를 빌딩 블록으로 사용하고 가변 변수와 루프, 명령적 통제 구조를 피하기 위한 프로그래밍 패러다임
- 함수형 프로그래밍에선 프로그램이 함수의 집합으로 구성된다.
- 함수형 프로그래밍은 다음과 같은 장점들이 있다.
  1. 프로그래머의 생산성을 향상시킨다.
  2. 병렬처리, 멀티스레드 애플리케이션을 쉽게 만들 수 있다.
  3. 견고한 코드로 프로그래밍 에러를 더 쉽게 피할 수 있다.

### 1.1. 함수
함수형 프로그래밍에서 함수는 실행되는 코드 단위다.

#### 최상급
- 함수는 변수나 값과 동일한 상태를 가지며, 함수를 변수처럼 사용할 수도 있다.
- 명령형 프로그래밍은 변수와 함수를 다르게 취급하지만, 함수형 프로그래밍은 함수가 함수의 입력으로 전달되거나 다른 함수의 결과값으로
리턴되는 것을 허용한다.
- 함수는 함수 내부를 포함하여 어디서든 정의될 수 있고, 다른 함수의 입력값으로 전달될 수 있다.

### 1.2. 불변 데이터 구조
- 순수 함수형 프로그래밍은 변경 가능한 데이터 구조나 변수를 사용하지 않는다.
- 불변 데이터 구조는 다음과 같은 이점을 갖는다.
  1. 버그를 줄일 수 있다.
  2. 멀티스레드 애플리케이션을 만들기 쉽다.

### 1.3. 표현식
함수형 프로그래밍에서 모든 구문은 값을 리턴하는 표현식이다. 예로, 스칼라에서 if-else 구문은 값을 리턴하는 표현식이다.

## 2. 스칼라 기본
- 스칼라는 객체 지향과 함수형 프로그래밍을 모두 지원하는 하이브리드 프로그래밍 언어다.
  - 불변 데이터 구조와 최상급 함수 등
- 스칼라는 정적인 유형의 언어다. 애플리케이션이 스칼라 컴파일러에 의해 컴파일되며, <b>컴파일 중에 데이터 타입을 체크</b>한다.
- 스칼라는 JVM을 기반으로 하는 언어다. 스칼라 컴파일러에 의해 어떤 JVM에서도 수행 가능한 자바 바이트코드로 컴파일된다.
<b>바이트코드 수준에서는 스칼라 애플리케이션과 자바 애플리케이션이 구별되지 않는다</b>.



### 2.1. 기본 형식

스칼라는 primitive type이 없다. 
애플리케이션이 자바 바이트코드로 컴파일될 떄, 스칼라의 타입은 자바의 primitive type으로 변경된다. (성능 최적화)

| 변수 형식 | 설명 |
| :---      | :--- |
|Byte       |8bit 정수|
|Short      |16bit 정수|
|Int        |32bit 정수|
|Long       |64bit 정수|
|Float      |32bit 부동소수점 실수|
|Double     |64bit 부동소수점 실수|
|Char       |16bit 유니코드 문자|
|String     |문자열|
|Boolean    |참 혹은 거짓|

### 2.2. 변수
- 가변변수 var
- 불변변수 val
- 가변변수의 사용은 권장되지 않는다.

### 2.3. 함수
- 함수는 값을 리턴하는 실행 코드의 묶음이다.
- 함수는 변수처럼 사용되거나 다른 함수의 입력값으로 전달될 수도 있다(리터럴 함수).
- 함수의 리턴 데이터 형식이 생략되더라도 컴파일러가 코드로부터 유추할 수 있다. 다음 두 함수는 기능적으로 동일하다.
  ```scala
  def add(a: Int, b: Int): Int = {
    val sum = a + b
    return sum
  }
  ```
  ```scala
  def add(a: Int, b: Int) => a + b
  ```

#### 메소드
메소드는 객체를 구성하는 함수로, 함수처럼 정의되고 사용된다. 객체의 모든 것에 접근 가능하다.

#### 지역 함수 (local function)
다른 함수나 메소드 안에서 정의된 함수.

#### 고차원 메소드
입력 파라미터로 함수를 쓸 수 있는 메소드를 고차원 메소드(higher-order method)라 한다.
```scala
def encode(n: Int, f: (Int) => Long): Long = {
  val x = n * 10
  f(x)
}
```

#### 리터럴 함수 (function literal)
이름이 정의되지 않은 함수로, 리터럴 문자처럼 사용될 수 있다.
고차원 메소드나 함수의 입력값으로 전달되거나 변수에 할당될 수 있다.
```scala
(x: Int) => {
  x + 100
}
```
```scala
(x: Int) => x + 100
```
```scala
val addh = (x: Int) => x + 100
```

#### 클로저 (closure)
스칼라는 리터럴함수가 환경 변수를 사용할 수 있게 해준다.
클로저는 환경 변수를 사용할 수 있는 리터럴함수다.

다음 예시에서 encode 메소드는 환경변수인 seed를 입력으로 받는 리터럴함수이므로 클로저이다.
```scala
def encodeWithSeed(num: Int, seed: Int): Long = {
  
  def encode(x: Int, f: (Int) => Long): Long = {
    val y = x + 1000
    f(y)
  }
  
  val result = encode(num, (n: Int) => (n * seed))
  resultd
}
```



### 2.4. 클래스
- 클래스는 객체 지향 프로그래밍의 개념으로 고수준의 프로그래밍 추상화를 제공한다.
- 스칼라에서 클래스는 다른 객체 지향 언어와 유사하다.
- 클래스의 인스턴스는 ```new``` 키워드로 만든다.
  ```scala
  class Car(c: String) {
    var color = mk

    def repaint(newColor: String) = {
      color = newColor
    }
  }

  val mustang = new Car("Red")
  ```

### 2.5. 싱글톤 (Singleton)
- 객체 지향 프로그래밍에서 클래스를 한 번만 인스턴스화할 수 있는 기법을 싱글톤(Singleton)이라 한다.
- 스칼라에선 싱글톤 클래스를 정의하기 위해 ```object``` 키워드를 제공한다.
  ```scala
  object DatabaseConnection {
    def open(name: String): Int = {...}
  }
  ```


### 2.6. Case 클래스
- ```new``` 키워드 없이 case 클래스 인스턴스를 만들 수 있다.
  ```scala
  case class Message(from: String, to: String)
  
  val request = Message("harry", "sam")
  ```
- case 클래스에 입력 파라미터는 ```val``` 접두어를 가진다. 즉, 클래스 필드는 변경 불가능하며 임의 조작 염려 없이 외부에서 접근할 수 있다.



### 2.7. 패턴 매칭
(생략)

### 2.8. 연산자
(생략)

### 2.9. 트레이트 (trait)
- 클래스를 지원하는 인터페이스
- 모듈성, 재사용성, 확장성있는 코드를 만들기 위한 추상화 메커니즘
- 자바의 인터페이스와 유사하나, 트레이트는 메소드를 구현할 수 있고 필드 변수를 가질 수도 있다.
- 필드와 메소드를 가진다는 점에서 추상 클래스와 유사하나, 트레이트는 다수의 트레이트를 상속할 수 있다.
  ```scala
  trait Shape {
    def area(): Int
  }
  
  class Square(length: Int) extends Shape {
    def area = length * length
  }
  ```

### 2.10. 튜플

### 2.11. 옵션 타입

### 2.12. 컬렉션





## Reference
- 도서 "스파크를 활용한 빅데이터 분석", 비제이퍼블릭, 모하마드 굴러
